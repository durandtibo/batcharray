{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p><code>batcharray</code> is lightweight library built on top of NumPy to manipulate nested data structure with NumPy arrays. This library provides functions for arrays where the first axis is the batch axis. It also provides functions for arrays representing a batch of sequences where the first axis is the batch axis and the second axis is the sequence axis.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Batch Operations: Manipulate arrays with a dedicated batch dimension</li> <li>Sequence Support: Handle time-series and sequential data efficiently</li> <li>Nested Structures: Work with dictionaries and lists of arrays seamlessly</li> <li>Masked Arrays: Built-in support for handling missing or invalid data</li> <li>Type Safety: Computation models for different array types</li> <li>Zero Dependencies: Lightweight with only NumPy as a core dependency</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Get Started - Installation and setup</li> <li>Tutorials - Step-by-step guides</li> <li>User Guide - Detailed documentation</li> <li>API Reference - Complete function reference</li> <li>FAQ - Common questions</li> </ul>"},{"location":"#motivation","title":"Motivation","text":"<p>Let's imagine you have a batch which is represented by a dictionary with three arrays, and you want to take the first 2 items. <code>batcharray</code> provides the function <code>slice_along_batch</code> that allows to slide all the arrays:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import slice_along_batch\n&gt;&gt;&gt; batch = {\n...     \"a\": np.array([[2, 6], [0, 3], [4, 9], [8, 1], [5, 7]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n...     \"c\": np.array([1.0, 2.0, 3.0, 4.0, 5.0]),\n... }\n&gt;&gt;&gt; slice_along_batch(batch, stop=2)\n{'a': array([[2, 6], [0, 3]]), 'b': array([4, 3]), 'c': array([1., 2.])}\n</code></pre> <p>Similarly, it is possible to split a batch in multiple batches by using the function <code>split_along_batch</code>:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import split_along_batch\n&gt;&gt;&gt; batch = {\n...     \"a\": np.array([[2, 6], [0, 3], [4, 9], [8, 1], [5, 7]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n...     \"c\": np.array([1.0, 2.0, 3.0, 4.0, 5.0]),\n... }\n&gt;&gt;&gt; split_along_batch(batch, split_size_or_sections=2)\n[{'a': array([[2, 6], [0, 3]]), 'b': array([4, 3]), 'c': array([1., 2.])},\n {'a': array([[4, 9], [8, 1]]), 'b': array([2, 1]), 'c': array([3., 4.])},\n {'a': array([[5, 7]]), 'b': array([0]), 'c': array([5.])}]\n</code></pre> <p>Please check the documentation to see all the implemented functions.</p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":""},{"location":"#for-beginners","title":"For Beginners","text":"<ul> <li>Get Started - Install and set up batcharray</li> <li>Working with Batches Tutorial - Learn basic batch operations</li> <li>FAQ - Common questions and answers</li> </ul>"},{"location":"#for-users","title":"For Users","text":"<ul> <li>Working with Sequences Tutorial - Handle time-series data</li> <li>Advanced Nested Operations Tutorial - Master complex structures</li> <li>User Guide: Array Operations - Complete guide to array functions</li> <li>User Guide: Nested Structures - Working with nested data</li> <li>User Guide: Computation Models - Low-level abstractions</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>array module - Single array operations</li> <li>nested module - Nested structure operations</li> <li>computation module - Computation models</li> <li>constants module - Package constants</li> <li>types module - Type definitions</li> </ul>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>batcharray</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>batcharray</code> to a new version will possibly break any code that was using the old version of <code>batcharray</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>batcharray</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-uv-pip-recommended","title":"Installing with <code>uv pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>uv pip install batcharray\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>batcharray</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code>uv pip install 'batcharray[all]'\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>batcharray</code> from source for development purposes, please refer to the development setup instructions in the CONTRIBUTING.md file in the repository.</p>"},{"location":"refs/array/","title":"array","text":""},{"location":"refs/array/#batcharray.array","title":"batcharray.array","text":"<p>Contain functions to manipulate arrays.</p>"},{"location":"refs/array/#batcharray.array.amax_along_batch","title":"batcharray.array.amax_along_batch","text":"<pre><code>amax_along_batch(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the maximum of all elements along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The maximum of all elements along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import amax_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = amax_along_batch(array)\n&gt;&gt;&gt; out\narray([8, 9])\n&gt;&gt;&gt; out = amax_along_batch(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[8, 9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.amax_along_seq","title":"batcharray.array.amax_along_seq","text":"<pre><code>amax_along_seq(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the maximum of all elements along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The maximum of all elements along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import amax_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = amax_along_seq(array)\n&gt;&gt;&gt; out\narray([4, 9])\n&gt;&gt;&gt; out = amax_along_seq(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[4], [9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.amin_along_batch","title":"batcharray.array.amin_along_batch","text":"<pre><code>amin_along_batch(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the minimum of all elements along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The minimum of all elements along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import amin_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = amin_along_batch(array)\n&gt;&gt;&gt; out\narray([0, 1])\n&gt;&gt;&gt; out = amin_along_batch(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[0, 1]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.amin_along_seq","title":"batcharray.array.amin_along_seq","text":"<pre><code>amin_along_seq(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the minimum of all elements along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The minimum of all elements along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import amin_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = amin_along_seq(array)\n&gt;&gt;&gt; out\narray([0, 5])\n&gt;&gt;&gt; out = amin_along_seq(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[0], [5]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.argmax_along_batch","title":"batcharray.array.argmax_along_batch","text":"<pre><code>argmax_along_batch(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the indices of the maximum value of all elements along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The indices of the maximum value of all elements along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import argmax_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = argmax_along_batch(array)\n&gt;&gt;&gt; out\narray([4, 4])\n&gt;&gt;&gt; out = argmax_along_batch(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[4, 4]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.argmax_along_seq","title":"batcharray.array.argmax_along_seq","text":"<pre><code>argmax_along_seq(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the indices of the maximum value of all elements along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The indices of the maximum value of all elements along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import argmax_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = argmax_along_seq(array)\n&gt;&gt;&gt; out\narray([4, 4])\n&gt;&gt;&gt; out = argmax_along_seq(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[4], [4]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.argmin_along_batch","title":"batcharray.array.argmin_along_batch","text":"<pre><code>argmin_along_batch(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the indices of the minimum value of all elements along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The indices of the minimum value of all elements along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import argmin_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = argmin_along_batch(array)\n&gt;&gt;&gt; out\narray([0, 0])\n&gt;&gt;&gt; out = argmin_along_batch(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[0, 0]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.argmin_along_seq","title":"batcharray.array.argmin_along_seq","text":"<pre><code>argmin_along_seq(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the indices of the minimum value of all elements along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The indices of the minimum value of all elements along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import argmin_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = argmin_along_seq(array)\n&gt;&gt;&gt; out\narray([0, 0])\n&gt;&gt;&gt; out = argmin_along_seq(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[0], [0]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.argsort_along_batch","title":"batcharray.array.argsort_along_batch","text":"<pre><code>argsort_along_batch(\n    array: ndarray, kind: SortKind | None = None\n) -&gt; ndarray\n</code></pre> <p>Return the indices that sort an array along the batch axis in ascending order by value.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The indices that sort the array along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import argsort_along_batch\n&gt;&gt;&gt; array = np.array([[2, 6], [0, 3], [4, 9], [8, 1], [5, 7]])\n&gt;&gt;&gt; out = argsort_along_batch(array)\n&gt;&gt;&gt; out\narray([[1, 3], [0, 1], [2, 0], [4, 4], [3, 2]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.argsort_along_seq","title":"batcharray.array.argsort_along_seq","text":"<pre><code>argsort_along_seq(\n    array: ndarray, kind: SortKind | None = None\n) -&gt; ndarray\n</code></pre> <p>Return the indices that sort an array along the sequence axis in ascending order by value.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The indices that sort the array along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import argsort_along_seq\n&gt;&gt;&gt; array = np.array([[7, 3, 0, 8, 5], [1, 9, 6, 4, 2]])\n&gt;&gt;&gt; out = argsort_along_seq(array)\n&gt;&gt;&gt; out\narray([[2, 1, 4, 0, 3],\n       [0, 4, 3, 2, 1]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.chunk_along_batch","title":"batcharray.array.chunk_along_batch","text":"<pre><code>chunk_along_batch(\n    array: ndarray, chunks: int\n) -&gt; list[ndarray]\n</code></pre> <p>Split the array into chunks along the batch axis.</p> <p>Each chunk is a view of the input array.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The array to split.</p> required <code>chunks</code> <code>int</code> <p>Number of chunks to return.</p> required <p>Returns:</p> Type Description <code>list[ndarray]</code> <p>The array chunks.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import chunk_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; outputs = chunk_along_batch(array, chunks=3)\n&gt;&gt;&gt; outputs\n[array([[0, 1], [2, 3]]), array([[4, 5], [6, 7]]), array([[8, 9]])]\n</code></pre>"},{"location":"refs/array/#batcharray.array.chunk_along_seq","title":"batcharray.array.chunk_along_seq","text":"<pre><code>chunk_along_seq(\n    array: ndarray, chunks: int\n) -&gt; list[ndarray]\n</code></pre> <p>Split the array into chunks along the sequence axis.</p> <p>Each chunk is a view of the input array.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The array to split.</p> required <code>chunks</code> <code>int</code> <p>Number of chunks to return.</p> required <p>Returns:</p> Type Description <code>list[ndarray]</code> <p>The array chunks.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import chunk_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; outputs = chunk_along_seq(array, chunks=3)\n&gt;&gt;&gt; outputs\n[array([[0, 1], [5, 6]]), array([[2, 3], [7, 8]]), array([[4], [9]])]\n</code></pre>"},{"location":"refs/array/#batcharray.array.concatenate_along_batch","title":"batcharray.array.concatenate_along_batch","text":"<pre><code>concatenate_along_batch(\n    arrays: list[ndarray] | tuple[ndarray, ...],\n) -&gt; ndarray\n</code></pre> <p>Concatenate the given arrays in the batch axis.</p> <p>All arrays must either have the same data type and shape (except in the concatenating axis) or be empty.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>list[ndarray] | tuple[ndarray, ...]</code> <p>The arrays to concatenate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The concatenated arrays along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import concatenate_along_batch\n&gt;&gt;&gt; arrays = [\n...     np.array([[0, 1, 2], [4, 5, 6]]),\n...     np.array([[10, 11, 12], [13, 14, 15]]),\n... ]\n&gt;&gt;&gt; out = concatenate_along_batch(arrays)\n&gt;&gt;&gt; out\narray([[ 0,  1,  2],\n       [ 4,  5,  6],\n       [10, 11, 12],\n       [13, 14, 15]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.concatenate_along_seq","title":"batcharray.array.concatenate_along_seq","text":"<pre><code>concatenate_along_seq(\n    arrays: list[ndarray] | tuple[ndarray, ...],\n) -&gt; ndarray\n</code></pre> <p>Concatenate the given arrays in the sequence axis.</p> <p>All arrays must either have the same data type and shape (except in the concatenating axis) or be empty.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>list[ndarray] | tuple[ndarray, ...]</code> <p>The arrays to concatenate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The concatenated arrays along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import concatenate_along_seq\n&gt;&gt;&gt; arrays = [\n...     np.array([[0, 1, 2], [4, 5, 6]]),\n...     np.array([[10, 11], [12, 13]]),\n... ]\n&gt;&gt;&gt; out = concatenate_along_seq(arrays)\n&gt;&gt;&gt; out\narray([[ 0,  1,  2, 10, 11],\n       [ 4,  5,  6, 12, 13]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.cumprod_along_batch","title":"batcharray.array.cumprod_along_batch","text":"<pre><code>cumprod_along_batch(array: ndarray) -&gt; ndarray\n</code></pre> <p>Return the cumulative product of elements of input in the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The cumulative product of elements of input in the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import cumprod_along_batch\n&gt;&gt;&gt; array = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]])\n&gt;&gt;&gt; out = cumprod_along_batch(array)\n&gt;&gt;&gt; out\narray([[   1,    2], [   3,    8], [  15,   48], [ 105,  384], [ 945, 3840]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.cumprod_along_seq","title":"batcharray.array.cumprod_along_seq","text":"<pre><code>cumprod_along_seq(array: ndarray) -&gt; ndarray\n</code></pre> <p>Return the cumulative product of elements of input in the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The cumulative product of elements of input in the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import cumprod_along_seq\n&gt;&gt;&gt; array = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])\n&gt;&gt;&gt; out = cumprod_along_seq(array)\n&gt;&gt;&gt; out\narray([[    1,     2,     6,    24,   120],\n        [    6,    42,   336,  3024, 30240]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.cumsum_along_batch","title":"batcharray.array.cumsum_along_batch","text":"<pre><code>cumsum_along_batch(array: ndarray) -&gt; ndarray\n</code></pre> <p>Return the cumulative sum of elements of input in the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The cumulative sum of elements of input in the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import cumsum_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = cumsum_along_batch(array)\n&gt;&gt;&gt; out\narray([[ 0,  1], [ 2,  4], [ 6,  9], [12, 16], [20, 25]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.cumsum_along_seq","title":"batcharray.array.cumsum_along_seq","text":"<pre><code>cumsum_along_seq(array: ndarray) -&gt; ndarray\n</code></pre> <p>Return the cumulative sum of elements of input in the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The cumulative sum of elements of input in the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import cumsum_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = cumsum_along_seq(array)\n&gt;&gt;&gt; out\narray([[ 0,  1,  3,  6, 10],\n       [ 5, 11, 18, 26, 35]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.index_select_along_batch","title":"batcharray.array.index_select_along_batch","text":"<pre><code>index_select_along_batch(\n    array: ndarray, indices: ndarray\n) -&gt; ndarray\n</code></pre> <p>Return a new array which indexes the input array along the batch axis using the entries in <code>indices</code>.</p> Note <p>This function assumes the batch axis is the first axis.</p> Note <p>Equivalent to <code>take_along_batch</code>.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>indices</code> <code>ndarray</code> <p>The 1-D array containing the indices to take.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The indexed array along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import index_select_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = index_select_along_batch(array, np.array([2, 4]))\n&gt;&gt;&gt; out\narray([[4, 5],\n       [8, 9]])\n&gt;&gt;&gt; out = index_select_along_batch(array, np.array([4, 3, 2, 1, 0]))\n&gt;&gt;&gt; out\narray([[8, 9],\n       [6, 7],\n       [4, 5],\n       [2, 3],\n       [0, 1]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.index_select_along_seq","title":"batcharray.array.index_select_along_seq","text":"<pre><code>index_select_along_seq(\n    array: ndarray, indices: ndarray\n) -&gt; ndarray\n</code></pre> <p>Return a new array which indexes the input array along the sequence axis using the entries in <code>indices</code>.</p> Note <p>This function assumes the sequence axis is the second axis.</p> Note <p>Equivalent to <code>take_along_seq</code>.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>indices</code> <code>ndarray</code> <p>The 1-D array containing the indices to take.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The indexed array along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import index_select_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = index_select_along_seq(array, np.array([2, 4]))\n&gt;&gt;&gt; out\narray([[2, 4],\n       [7, 9]])\n&gt;&gt;&gt; out = index_select_along_seq(array, np.array([4, 3, 2, 1, 0]))\n&gt;&gt;&gt; out\narray([[4, 3, 2, 1, 0],\n       [9, 8, 7, 6, 5]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.masked_select_along_batch","title":"batcharray.array.masked_select_along_batch","text":"<pre><code>masked_select_along_batch(\n    array: ndarray, mask: ndarray\n) -&gt; ndarray\n</code></pre> <p>Return a new array which indexes the input array along the batch axis according to the boolean mask <code>mask</code>.</p> Note <p>This function assumes the batch axis is the first axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>mask</code> <code>ndarray</code> <p>The 1-D array containing the binary mask to index with.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The indexed array along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import masked_select_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = masked_select_along_batch(array, np.array([False, False, True, False, True]))\n&gt;&gt;&gt; out\narray([[4, 5], [8, 9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.masked_select_along_seq","title":"batcharray.array.masked_select_along_seq","text":"<pre><code>masked_select_along_seq(\n    array: ndarray, mask: ndarray\n) -&gt; ndarray\n</code></pre> <p>Return a new array which indexes the input array along the sequence axis according to the boolean mask <code>mask</code>.</p> Note <p>This function assumes the sequence axis is the second axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>mask</code> <code>ndarray</code> <p>The 1-D array containing the binary mask to index with.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The indexed array along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import masked_select_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = masked_select_along_seq(array, np.array([False, False, True, False, True]))\n&gt;&gt;&gt; out\narray([[2, 4], [7, 9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.max_along_batch","title":"batcharray.array.max_along_batch","text":"<pre><code>max_along_batch(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the maximum of all elements along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The maximum of the input array along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import max_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = max_along_batch(array)\n&gt;&gt;&gt; out\narray([8, 9])\n&gt;&gt;&gt; out = max_along_batch(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[8, 9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.max_along_seq","title":"batcharray.array.max_along_seq","text":"<pre><code>max_along_seq(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the maximum of all elements along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The maximum of the input array along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import max_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = max_along_seq(array)\n&gt;&gt;&gt; out\narray([4, 9])\n&gt;&gt;&gt; out = max_along_seq(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[4], [9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.mean_along_batch","title":"batcharray.array.mean_along_batch","text":"<pre><code>mean_along_batch(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the mean of all elements along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The mean of all elements along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import mean_along_batch\n&gt;&gt;&gt; array = np.array([[0.0, 1.0], [2.0, 3.0], [4.0, 5.0], [6.0, 7.0], [8.0, 9.0]])\n&gt;&gt;&gt; out = mean_along_batch(array)\n&gt;&gt;&gt; out\narray([4., 5.])\n&gt;&gt;&gt; out = mean_along_batch(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[4., 5.]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.mean_along_seq","title":"batcharray.array.mean_along_seq","text":"<pre><code>mean_along_seq(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the mean of all elements along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The mean of all elements along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import mean_along_seq\n&gt;&gt;&gt; array = np.array([[0.0, 1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0, 9.0]])\n&gt;&gt;&gt; out = mean_along_seq(array)\n&gt;&gt;&gt; out\narray([2., 7.])\n&gt;&gt;&gt; out = mean_along_seq(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[2.], [7.]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.median_along_batch","title":"batcharray.array.median_along_batch","text":"<pre><code>median_along_batch(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the median of all elements along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A new array holding the result. If the input contains integers or floats smaller than <code>np.float64</code>, then the output data-type is <code>np.float64</code>. Otherwise, the data-type of the output is the same as that of the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import median_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = median_along_batch(array)\n&gt;&gt;&gt; out\narray([4., 5.])\n&gt;&gt;&gt; out = median_along_batch(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[4., 5.]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.median_along_seq","title":"batcharray.array.median_along_seq","text":"<pre><code>median_along_seq(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the median of all elements along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A new array holding the result. If the input contains integers or floats smaller than <code>np.float64</code>, then the output data-type is <code>np.float64</code>. Otherwise, the data-type of the output is the same as that of the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import median_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = median_along_seq(array)\n&gt;&gt;&gt; out\narray([2., 7.])\n&gt;&gt;&gt; out = median_along_seq(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[2.], [7.]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.min_along_batch","title":"batcharray.array.min_along_batch","text":"<pre><code>min_along_batch(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the minimum of all elements along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The minimum of the input array along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import min_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = min_along_batch(array)\n&gt;&gt;&gt; out\narray([0, 1])\n&gt;&gt;&gt; out = min_along_batch(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[0, 1]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.min_along_seq","title":"batcharray.array.min_along_seq","text":"<pre><code>min_along_seq(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the minimum of all elements along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The minimum of the input array along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import min_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = min_along_seq(array)\n&gt;&gt;&gt; out\narray([0, 5])\n&gt;&gt;&gt; out = min_along_seq(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[0], [5]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.permute_along_batch","title":"batcharray.array.permute_along_batch","text":"<pre><code>permute_along_batch(\n    array: ndarray, permutation: ndarray\n) -&gt; ndarray\n</code></pre> <p>Permute the array along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The array to split.</p> required <code>permutation</code> <code>ndarray</code> <p>The 1-D array containing the indices of the permutation. The shape should match the batch axis of the array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The array with permuted data along the batch axis.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the shape of the permutation does not match the batch axis of the array.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import permute_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = permute_along_batch(array, np.array([2, 1, 3, 0, 4]))\n&gt;&gt;&gt; out\narray([[4, 5],\n       [2, 3],\n       [6, 7],\n       [0, 1],\n       [8, 9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.permute_along_seq","title":"batcharray.array.permute_along_seq","text":"<pre><code>permute_along_seq(\n    array: ndarray, permutation: ndarray\n) -&gt; ndarray\n</code></pre> <p>Permute the array along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The array to split.</p> required <code>permutation</code> <code>ndarray</code> <p>The 1-D array containing the indices of the permutation. The shape should match the sequence axis of the array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The array with permuted data along the sequence axis.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the shape of the permutation does not match the sequence axis of the array.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import permute_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = permute_along_seq(array, np.array([2, 1, 3, 0, 4]))\n&gt;&gt;&gt; out\narray([[2, 1, 3, 0, 4],\n       [7, 6, 8, 5, 9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.prod_along_batch","title":"batcharray.array.prod_along_batch","text":"<pre><code>prod_along_batch(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the product of all elements along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The product of all elements along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import prod_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = prod_along_batch(array)\n&gt;&gt;&gt; out\narray([  0, 945])\n&gt;&gt;&gt; out = prod_along_batch(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[  0, 945]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.prod_along_seq","title":"batcharray.array.prod_along_seq","text":"<pre><code>prod_along_seq(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the product of all elements along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The product of all elements along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import prod_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = prod_along_seq(array)\n&gt;&gt;&gt; out\narray([    0, 15120])\n&gt;&gt;&gt; out = prod_along_seq(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[    0], [15120]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.select_along_batch","title":"batcharray.array.select_along_batch","text":"<pre><code>select_along_batch(array: ndarray, index: int) -&gt; ndarray\n</code></pre> <p>Slice the input array along the batch axis at the given index.</p> <p>This function returns a view of the original array with the batch axis removed.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>index</code> <code>int</code> <p>The index to select with.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The sliced array along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import select_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = select_along_batch(array, index=2)\n&gt;&gt;&gt; out\narray([4, 5])\n</code></pre>"},{"location":"refs/array/#batcharray.array.select_along_seq","title":"batcharray.array.select_along_seq","text":"<pre><code>select_along_seq(array: ndarray, index: int) -&gt; ndarray\n</code></pre> <p>Slice the input array along the sequence axis at the given index.</p> <p>This function returns a view of the original array with the sequence axis removed.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>index</code> <code>int</code> <p>The index to select with.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The sliced array along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import select_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = select_along_seq(array, index=2)\n&gt;&gt;&gt; out\narray([2, 7])\n</code></pre>"},{"location":"refs/array/#batcharray.array.shuffle_along_batch","title":"batcharray.array.shuffle_along_batch","text":"<pre><code>shuffle_along_batch(\n    array: ndarray, rng: Generator | None = None\n) -&gt; ndarray\n</code></pre> <p>Shuffle the array along the batch dimension.</p> Note <p>This function assumes the batch axis is the first     dimension.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The array to split.</p> required <code>rng</code> <code>Generator | None</code> <p>An optional random number generator.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The shuffled array.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import shuffle_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = shuffle_along_batch(array)\n&gt;&gt;&gt; out\narray([[...]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.shuffle_along_seq","title":"batcharray.array.shuffle_along_seq","text":"<pre><code>shuffle_along_seq(\n    array: ndarray, rng: Generator | None = None\n) -&gt; ndarray\n</code></pre> <p>Shuffle the array along the batch dimension.</p> Note <p>This function assumes the sequence axis is the second     dimension.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The array to split.</p> required <code>rng</code> <code>Generator | None</code> <p>An optional random number generator.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The shuffled array.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import shuffle_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = shuffle_along_seq(array)\n&gt;&gt;&gt; out\narray([[...]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.slice_along_batch","title":"batcharray.array.slice_along_batch","text":"<pre><code>slice_along_batch(\n    array: ndarray,\n    start: int = 0,\n    stop: int | None = None,\n    step: int = 1,\n) -&gt; ndarray\n</code></pre> <p>Slice the array along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>start</code> <code>int</code> <p>The index where the slicing of object starts.</p> <code>0</code> <code>stop</code> <code>int | None</code> <p>The index where the slicing of object stops. <code>None</code> means last.</p> <code>None</code> <code>step</code> <code>int</code> <p>The increment between each index for slicing.</p> <code>1</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The sliced array along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import slice_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = slice_along_batch(array, start=2)\n&gt;&gt;&gt; out\narray([[4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = slice_along_batch(array, stop=3)\n&gt;&gt;&gt; out\narray([[0, 1], [2, 3], [4, 5]])\n&gt;&gt;&gt; out = slice_along_batch(array, step=2)\n&gt;&gt;&gt; out\narray([[0, 1], [4, 5], [8, 9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.slice_along_seq","title":"batcharray.array.slice_along_seq","text":"<pre><code>slice_along_seq(\n    array: ndarray,\n    start: int = 0,\n    stop: int | None = None,\n    step: int = 1,\n) -&gt; ndarray\n</code></pre> <p>Slice the array along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>start</code> <code>int</code> <p>The index where the slicing of object starts.</p> <code>0</code> <code>stop</code> <code>int | None</code> <p>The index where the slicing of object stops. <code>None</code> means last.</p> <code>None</code> <code>step</code> <code>int</code> <p>The increment between each index for slicing.</p> <code>1</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The sliced array along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import slice_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [9, 8, 7, 6, 5]])\n&gt;&gt;&gt; out = slice_along_seq(array, start=2)\n&gt;&gt;&gt; out\narray([[2, 3, 4], [7, 6, 5]])\n&gt;&gt;&gt; out = slice_along_seq(array, stop=3)\n&gt;&gt;&gt; out\narray([[0, 1, 2], [9, 8, 7]])\n&gt;&gt;&gt; out = slice_along_seq(array, step=2)\n&gt;&gt;&gt; out\narray([[0, 2, 4], [9, 7, 5]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.sort_along_batch","title":"batcharray.array.sort_along_batch","text":"<pre><code>sort_along_batch(\n    array: ndarray, kind: SortKind | None = None\n) -&gt; ndarray\n</code></pre> <p>Sort the elements of the input array along the batch axis in ascending order by value.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The sorted array along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import sort_along_batch\n&gt;&gt;&gt; array = np.array([[2, 6], [0, 3], [4, 9], [8, 1], [5, 7]])\n&gt;&gt;&gt; out = sort_along_batch(array)\n&gt;&gt;&gt; out\narray([[0, 1], [2, 3], [4, 6], [5, 7], [8, 9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.sort_along_seq","title":"batcharray.array.sort_along_seq","text":"<pre><code>sort_along_seq(\n    array: ndarray, kind: SortKind | None = None\n) -&gt; ndarray\n</code></pre> <p>Sort the elements of the input array along the sequence axis in ascending order by value.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The sorted array along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import sort_along_seq\n&gt;&gt;&gt; array = np.array([[7, 3, 0, 8, 5], [1, 9, 6, 4, 2]])\n&gt;&gt;&gt; out = sort_along_seq(array)\n&gt;&gt;&gt; out\narray([[0, 3, 5, 7, 8], [1, 2, 4, 6, 9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.split_along_batch","title":"batcharray.array.split_along_batch","text":"<pre><code>split_along_batch(\n    array: ndarray,\n    split_size_or_sections: int | Sequence[int],\n) -&gt; list[ndarray]\n</code></pre> <p>Split the array into chunks along the batch axis.</p> <p>Each chunk is a view of the original array.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>split_size_or_sections</code> <code>int | Sequence[int]</code> <p>Size of a single chunk or list of sizes for each chunk</p> required <p>Returns:</p> Type Description <code>list[ndarray]</code> <p>The array chunks.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import split_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; outputs = split_along_batch(array, split_size_or_sections=2)\n&gt;&gt;&gt; outputs\n[array([[0, 1], [2, 3]]), array([[4, 5], [6, 7]]), array([[8, 9]])]\n</code></pre>"},{"location":"refs/array/#batcharray.array.split_along_seq","title":"batcharray.array.split_along_seq","text":"<pre><code>split_along_seq(\n    array: ndarray,\n    split_size_or_sections: int | Sequence[int],\n) -&gt; list[ndarray]\n</code></pre> <p>Split the array into chunks along the sequence axis.</p> <p>Each chunk is a view of the original array.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>split_size_or_sections</code> <code>int | Sequence[int]</code> <p>Size of a single chunk or list of sizes for each chunk</p> required <p>Returns:</p> Type Description <code>list[ndarray]</code> <p>The array chunks.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import split_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; outputs = split_along_seq(array, split_size_or_sections=2)\n&gt;&gt;&gt; outputs\n[array([[0, 1], [5, 6]]), array([[2, 3], [7, 8]]), array([[4], [9]])]\n</code></pre>"},{"location":"refs/array/#batcharray.array.sum_along_batch","title":"batcharray.array.sum_along_batch","text":"<pre><code>sum_along_batch(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the sum of all elements along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The sum of all elements along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import sum_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = sum_along_batch(array)\n&gt;&gt;&gt; out\narray([20, 25])\n&gt;&gt;&gt; out = sum_along_batch(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[20, 25]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.sum_along_seq","title":"batcharray.array.sum_along_seq","text":"<pre><code>sum_along_seq(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the sum of all elements along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The sum of all elements along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import sum_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = sum_along_seq(array)\n&gt;&gt;&gt; out\narray([10, 35])\n&gt;&gt;&gt; out = sum_along_seq(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[10], [35]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.take_along_batch","title":"batcharray.array.take_along_batch","text":"<pre><code>take_along_batch(\n    array: ndarray, indices: ndarray\n) -&gt; ndarray\n</code></pre> <p>Return a new array which indexes the input array along the batch axis using the entries in <code>indices</code>.</p> Note <p>This function assumes the batch axis is the first axis.</p> Note <p>Equivalent to <code>index_select_along_batch</code>.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>indices</code> <code>ndarray</code> <p>The 1-D array containing the indices to take.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The indexed array along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import take_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = take_along_batch(array, np.array([2, 4]))\n&gt;&gt;&gt; out\narray([[4, 5],\n       [8, 9]])\n&gt;&gt;&gt; out = take_along_batch(array, np.array([4, 3, 2, 1, 0]))\n&gt;&gt;&gt; out\narray([[8, 9],\n       [6, 7],\n       [4, 5],\n       [2, 3],\n       [0, 1]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.take_along_seq","title":"batcharray.array.take_along_seq","text":"<pre><code>take_along_seq(array: ndarray, indices: ndarray) -&gt; ndarray\n</code></pre> <p>Return a new array which indexes the input array along the sequence axis using the entries in <code>indices</code>.</p> Note <p>This function assumes the sequence axis is the second axis.</p> Note <p>Equivalent to <code>index_select_along_seq</code>.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>indices</code> <code>ndarray</code> <p>The 1-D array containing the indices to take.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The indexed array along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import take_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = take_along_seq(array, np.array([2, 4]))\n&gt;&gt;&gt; out\narray([[2, 4],\n       [7, 9]])\n&gt;&gt;&gt; out = take_along_seq(array, np.array([4, 3, 2, 1, 0]))\n&gt;&gt;&gt; out\narray([[4, 3, 2, 1, 0],\n       [9, 8, 7, 6, 5]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.tile_along_seq","title":"batcharray.array.tile_along_seq","text":"<pre><code>tile_along_seq(array: ndarray, reps: int) -&gt; ndarray\n</code></pre> <p>Construct an array by repeating the input array along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>reps</code> <code>int</code> <p>The number of repetitions data along the sequence axis.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A new array with the data repeated along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import tile_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = tile_along_seq(array, 2)\n&gt;&gt;&gt; out\narray([[0, 1, 2, 3, 4, 0, 1, 2, 3, 4],\n       [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]])\n</code></pre>"},{"location":"refs/computation/","title":"computation","text":""},{"location":"refs/computation/#batcharray.computation","title":"batcharray.computation","text":"<p>Contain the computation models.</p>"},{"location":"refs/computation/#batcharray.computation.ArrayComputationModel","title":"batcharray.computation.ArrayComputationModel","text":"<p>               Bases: <code>BaseComputationModel[ndarray]</code></p> <p>Implement a computation model for <code>numpy.ndarray</code>s.</p>"},{"location":"refs/computation/#batcharray.computation.AutoComputationModel","title":"batcharray.computation.AutoComputationModel","text":"<p>               Bases: <code>BaseComputationModel[T]</code></p> <p>Implement a computation model that automatically finds the right computation model based on the array type.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import AutoComputationModel\n&gt;&gt;&gt; comp_model = AutoComputationModel()\n&gt;&gt;&gt; arrays = [\n...     np.array([[0, 1, 2], [4, 5, 6]]),\n...     np.array([[10, 11, 12], [13, 14, 15]]),\n... ]\n&gt;&gt;&gt; out = comp_model.concatenate(arrays, axis=0)\n&gt;&gt;&gt; out\narray([[ 0,  1,  2],\n       [ 4,  5,  6],\n       [10, 11, 12],\n       [13, 14, 15]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.AutoComputationModel.add_computation_model","title":"batcharray.computation.AutoComputationModel.add_computation_model  <code>classmethod</code>","text":"<pre><code>add_computation_model(\n    array_type: type[ndarray],\n    comp_model: BaseComputationModel[T],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add a computation model for a given array type.</p> <p>Parameters:</p> Name Type Description Default <code>array_type</code> <code>type[ndarray]</code> <p>The array type.</p> required <code>comp_model</code> <code>BaseComputationModel[T]</code> <p>The computation model to use for the given array type.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the data type already exists. This parameter should be set to <code>True</code> to overwrite the computation model for an array type.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a computation model is already registered for the array type and <code>exist_ok=False</code>.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import AutoComputationModel, ArrayComputationModel\n&gt;&gt;&gt; AutoComputationModel.add_computation_model(\n...     np.ndarray, ArrayComputationModel(), exist_ok=True\n... )\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.AutoComputationModel.find_computation_model","title":"batcharray.computation.AutoComputationModel.find_computation_model  <code>classmethod</code>","text":"<pre><code>find_computation_model(\n    array_type: type[ndarray],\n) -&gt; BaseComputationModel[T]\n</code></pre> <p>Find the computation model associated to an array type.</p> <p>Parameters:</p> Name Type Description Default <code>array_type</code> <code>type[ndarray]</code> <p>The array type.</p> required <p>Returns:</p> Type Description <code>BaseComputationModel[T]</code> <p>The computation model associated to the array type.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import AutoComputationModel\n&gt;&gt;&gt; AutoComputationModel.find_computation_model(np.ndarray)\nArrayComputationModel()\n&gt;&gt;&gt; AutoComputationModel.find_computation_model(np.ma.MaskedArray)\nMaskedArrayComputationModel()\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.AutoComputationModel.has_computation_model","title":"batcharray.computation.AutoComputationModel.has_computation_model  <code>classmethod</code>","text":"<pre><code>has_computation_model(array_type: type[ndarray]) -&gt; bool\n</code></pre> <p>Indicate if a computation model is registered for the given array type.</p> <p>Parameters:</p> Name Type Description Default <code>array_type</code> <code>type[ndarray]</code> <p>The array type.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if a computation model is registered, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import AutoComputationModel\n&gt;&gt;&gt; AutoComputationModel.has_computation_model(np.ndarray)\nTrue\n&gt;&gt;&gt; AutoComputationModel.has_computation_model(str)\nFalse\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.BaseComputationModel","title":"batcharray.computation.BaseComputationModel","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class for computation models.</p> <p>This class provides the interface that all computation models must implement. It can be extended to create custom computation models for different array types.</p>"},{"location":"refs/computation/#batcharray.computation.BaseComputationModel.argmax","title":"batcharray.computation.BaseComputationModel.argmax  <code>abstractmethod</code>","text":"<pre><code>argmax(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the array of indices of the maximum values along the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the argmax are computed. The default (<code>None</code>) is to compute the argmax along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>The array of indices of the maximum values along the given axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import ArrayComputationModel\n&gt;&gt;&gt; comp_model = ArrayComputationModel()\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = comp_model.argmax(array, axis=0)\n&gt;&gt;&gt; out\narray([4, 4])\n&gt;&gt;&gt; out = comp_model.argmax(array, axis=1)\n&gt;&gt;&gt; out\narray([1, 1, 1, 1, 1])\n&gt;&gt;&gt; out = comp_model.argmax(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[4, 4]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.BaseComputationModel.argmin","title":"batcharray.computation.BaseComputationModel.argmin  <code>abstractmethod</code>","text":"<pre><code>argmin(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the array of indices of the minimum values along the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the argmin are computed. The default (<code>None</code>) is to compute the argmin along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>The array of indices of the minimum values along the given axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import ArrayComputationModel\n&gt;&gt;&gt; comp_model = ArrayComputationModel()\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = comp_model.argmin(array, axis=0)\n&gt;&gt;&gt; out\narray([0, 0])\n&gt;&gt;&gt; out = comp_model.argmin(array, axis=1)\n&gt;&gt;&gt; out\narray([0, 0, 0, 0, 0])\n&gt;&gt;&gt; out = comp_model.argmin(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[0, 0]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.BaseComputationModel.argsort","title":"batcharray.computation.BaseComputationModel.argsort  <code>abstractmethod</code>","text":"<pre><code>argsort(\n    arr: T,\n    axis: int | None = None,\n    *,\n    kind: SortKind | None = None\n) -&gt; T\n</code></pre> <p>Return the indices that sort an array along the given axis in ascending order by value.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which to sort. The default (<code>None</code>) is to sort along a flattened version of the array.</p> <code>None</code> <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>The indices that sort the array along the given axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import ArrayComputationModel\n&gt;&gt;&gt; comp_model = ArrayComputationModel()\n&gt;&gt;&gt; array = np.array([[3, 5, 0, 2, 4], [4, 7, 8, 9, 5], [7, 5, 8, 9, 0]])\n&gt;&gt;&gt; out = comp_model.argsort(array, axis=0)\n&gt;&gt;&gt; out\narray([[0, 0, 0, 0, 2],\n       [1, 2, 1, 1, 0],\n       [2, 1, 2, 2, 1]])\n&gt;&gt;&gt; out = comp_model.argsort(array, axis=1)\n&gt;&gt;&gt; out\narray([[2, 3, 0, 4, 1],\n       [0, 4, 1, 2, 3],\n       [4, 1, 0, 2, 3]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.BaseComputationModel.concatenate","title":"batcharray.computation.BaseComputationModel.concatenate  <code>abstractmethod</code>","text":"<pre><code>concatenate(\n    arrays: Sequence[T],\n    axis: int | None = None,\n    *,\n    dtype: DTypeLike = None\n) -&gt; T\n</code></pre> <p>Concatenate a sequence of arrays along an existing axis.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>Sequence[T]</code> <p>The arrays to concatenate.</p> required <code>axis</code> <code>int | None</code> <p>The axis along which the arrays will be joined. If <code>axis</code> is None, arrays are flattened before use.</p> <code>None</code> <code>dtype</code> <code>DTypeLike</code> <p>If provided, the destination array will have this data type.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>The concatenated array.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import ArrayComputationModel\n&gt;&gt;&gt; comp_model = ArrayComputationModel()\n&gt;&gt;&gt; arrays = [\n...     np.array([[0, 1, 2], [4, 5, 6]]),\n...     np.array([[10, 11, 12], [13, 14, 15]]),\n... ]\n&gt;&gt;&gt; out = comp_model.concatenate(arrays, axis=0)\n&gt;&gt;&gt; out\narray([[ 0,  1,  2],\n       [ 4,  5,  6],\n       [10, 11, 12],\n       [13, 14, 15]])\n&gt;&gt;&gt; out = comp_model.concatenate(arrays, axis=1)\n&gt;&gt;&gt; out\narray([[ 0,  1,  2, 10, 11, 12],\n       [ 4,  5,  6, 13, 14, 15]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.BaseComputationModel.max","title":"batcharray.computation.BaseComputationModel.max  <code>abstractmethod</code>","text":"<pre><code>max(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the maximum along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the maximum values are computed. The default (<code>None</code>) is to compute the maximum along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>The maximum of the input array along the given axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import ArrayComputationModel\n&gt;&gt;&gt; comp_model = ArrayComputationModel()\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = comp_model.max(array, axis=0)\n&gt;&gt;&gt; out\narray([8, 9])\n&gt;&gt;&gt; out = comp_model.max(array, axis=1)\n&gt;&gt;&gt; out\narray([1, 3, 5, 7, 9])\n&gt;&gt;&gt; out = comp_model.max(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[8, 9]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.BaseComputationModel.mean","title":"batcharray.computation.BaseComputationModel.mean  <code>abstractmethod</code>","text":"<pre><code>mean(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the mean along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the means are computed. The default (<code>None</code>) is to compute the mean along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>A new array holding the result. If the input contains integers or floats smaller than <code>np.float64</code>, then the output data-type is <code>np.float64</code>. Otherwise, the data-type of the output is the same as that of the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import ArrayComputationModel\n&gt;&gt;&gt; comp_model = ArrayComputationModel()\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = comp_model.mean(array, axis=0)\n&gt;&gt;&gt; out\narray([4., 5.])\n&gt;&gt;&gt; out = comp_model.mean(array, axis=1)\n&gt;&gt;&gt; out\narray([0.5, 2.5, 4.5, 6.5, 8.5])\n&gt;&gt;&gt; out = comp_model.mean(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[4., 5.]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.BaseComputationModel.median","title":"batcharray.computation.BaseComputationModel.median  <code>abstractmethod</code>","text":"<pre><code>median(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the median along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the medians are computed. The default (<code>None</code>) is to compute the median along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>A new array holding the result. If the input contains integers or floats smaller than <code>np.float64</code>, then the output data-type is <code>np.float64</code>. Otherwise, the data-type of the output is the same as that of the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import ArrayComputationModel\n&gt;&gt;&gt; comp_model = ArrayComputationModel()\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = comp_model.median(array, axis=0)\n&gt;&gt;&gt; out\narray([4., 5.])\n&gt;&gt;&gt; out = comp_model.median(array, axis=1)\n&gt;&gt;&gt; out\narray([0.5, 2.5, 4.5, 6.5, 8.5])\n&gt;&gt;&gt; out = comp_model.median(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[4., 5.]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.BaseComputationModel.min","title":"batcharray.computation.BaseComputationModel.min  <code>abstractmethod</code>","text":"<pre><code>min(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the minimum along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the minimum values are computed. The default (<code>None</code>) is to compute the minimum along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>The minimum of the input array along the given axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import ArrayComputationModel\n&gt;&gt;&gt; comp_model = ArrayComputationModel()\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = comp_model.min(array, axis=0)\n&gt;&gt;&gt; out\narray([0, 1])\n&gt;&gt;&gt; out = comp_model.min(array, axis=1)\n&gt;&gt;&gt; out\narray([0, 2, 4, 6, 8])\n&gt;&gt;&gt; out = comp_model.min(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[0, 1]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.BaseComputationModel.sort","title":"batcharray.computation.BaseComputationModel.sort  <code>abstractmethod</code>","text":"<pre><code>sort(\n    arr: T,\n    axis: int | None = None,\n    *,\n    kind: SortKind | None = None\n) -&gt; T\n</code></pre> <p>Sort the elements of the input array along the given axis in ascending order by value.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which to sort. The default (<code>None</code>) is to sort along a flattened version of the array.</p> <code>None</code> <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>The sorted array along the given axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import ArrayComputationModel\n&gt;&gt;&gt; comp_model = ArrayComputationModel()\n&gt;&gt;&gt; array = np.array([[3, 5, 0, 2, 4], [4, 7, 8, 8, 5], [8, 5, 8, 8, 0]])\n&gt;&gt;&gt; out = comp_model.sort(array, axis=0)\n&gt;&gt;&gt; out\narray([[3, 5, 0, 2, 0],\n       [4, 5, 8, 8, 4],\n       [8, 7, 8, 8, 5]])\n&gt;&gt;&gt; out = comp_model.sort(array, axis=1)\n&gt;&gt;&gt; out\narray([[0, 2, 3, 4, 5],\n       [4, 5, 7, 8, 8],\n       [0, 5, 8, 8, 8]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.MaskedArrayComputationModel","title":"batcharray.computation.MaskedArrayComputationModel","text":"<p>               Bases: <code>BaseComputationModel[MaskedArray]</code></p> <p>Implement a computation model for <code>numpy.ma.MaskedArray</code>s.</p>"},{"location":"refs/computation/#batcharray.computation.argmax","title":"batcharray.computation.argmax","text":"<pre><code>argmax(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the array of indices of the maximum values along the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the argmax are computed. The default (<code>None</code>) is to compute the argmax along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>The array of indices of the maximum values along the given axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import argmax\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = argmax(array, axis=0)\n&gt;&gt;&gt; out\narray([4, 4])\n&gt;&gt;&gt; out = argmax(array, axis=1)\n&gt;&gt;&gt; out\narray([1, 1, 1, 1, 1])\n&gt;&gt;&gt; out = argmax(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[4, 4]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.argmin","title":"batcharray.computation.argmin","text":"<pre><code>argmin(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the array of indices of the minimum values along the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the argmin are computed. The default (<code>None</code>) is to compute the argmin along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>The array of indices of the minimum values along the given axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import argmin\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = argmin(array, axis=0)\n&gt;&gt;&gt; out\narray([0, 0])\n&gt;&gt;&gt; out = argmin(array, axis=1)\n&gt;&gt;&gt; out\narray([0, 0, 0, 0, 0])\n&gt;&gt;&gt; out = argmin(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[0, 0]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.argsort","title":"batcharray.computation.argsort","text":"<pre><code>argsort(\n    arr: T,\n    axis: int | None = None,\n    *,\n    kind: SortKind | None = None\n) -&gt; T\n</code></pre> <p>Return the indices that sort an array along the given axis in ascending order by value.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which to sort. The default (<code>None</code>) is to sort along a flattened version of the array.</p> <code>None</code> <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>The indices that sort the array along the given axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import ArrayComputationModel\n&gt;&gt;&gt; comp_model = ArrayComputationModel()\n&gt;&gt;&gt; array = np.array([[3, 5, 0, 2, 4], [4, 7, 8, 9, 5], [7, 5, 8, 9, 0]])\n&gt;&gt;&gt; out = comp_model.argsort(array, axis=0)\n&gt;&gt;&gt; out\narray([[0, 0, 0, 0, 2],\n       [1, 2, 1, 1, 0],\n       [2, 1, 2, 2, 1]])\n&gt;&gt;&gt; out = comp_model.argsort(array, axis=1)\n&gt;&gt;&gt; out\narray([[2, 3, 0, 4, 1],\n       [0, 4, 1, 2, 3],\n       [4, 1, 0, 2, 3]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.concatenate","title":"batcharray.computation.concatenate","text":"<pre><code>concatenate(\n    arrays: Sequence[T],\n    axis: int | None = None,\n    *,\n    dtype: DTypeLike = None\n) -&gt; T\n</code></pre> <p>Concatenate a sequence of arrays along an existing axis.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>Sequence[T]</code> <p>The arrays to concatenate.</p> required <code>axis</code> <code>int | None</code> <p>The axis along which the arrays will be joined. If <code>axis</code> is None, arrays are flattened before use.</p> <code>None</code> <code>dtype</code> <code>DTypeLike</code> <p>If provided, the destination array will have this data type.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>The concatenated array.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import concatenate\n&gt;&gt;&gt; arrays = [\n...     np.array([[0, 1, 2], [4, 5, 6]]),\n...     np.array([[10, 11, 12], [13, 14, 15]]),\n... ]\n&gt;&gt;&gt; out = concatenate(arrays, axis=0)\n&gt;&gt;&gt; out\narray([[ 0,  1,  2],\n       [ 4,  5,  6],\n       [10, 11, 12],\n       [13, 14, 15]])\n&gt;&gt;&gt; out = concatenate(arrays, axis=1)\n&gt;&gt;&gt; out\narray([[ 0,  1,  2, 10, 11, 12],\n       [ 4,  5,  6, 13, 14, 15]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.max","title":"batcharray.computation.max","text":"<pre><code>max(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the maximum along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the maximum values are computed. The default (<code>None</code>) is to compute the maximum along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>The maximum of the input array along the given axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import max\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = max(array, axis=0)\n&gt;&gt;&gt; out\narray([8, 9])\n&gt;&gt;&gt; out = max(array, axis=1)\n&gt;&gt;&gt; out\narray([1, 3, 5, 7, 9])\n&gt;&gt;&gt; out = max(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[8, 9]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.mean","title":"batcharray.computation.mean","text":"<pre><code>mean(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the mean along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the means are computed. The default (<code>None</code>) is to compute the mean along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>A new array holding the result. If the input contains integers or floats smaller than <code>np.float64</code>, then the output data-type is <code>np.float64</code>. Otherwise, the data-type of the output is the same as that of the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import mean\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = mean(array, axis=0)\n&gt;&gt;&gt; out\narray([4., 5.])\n&gt;&gt;&gt; out = mean(array, axis=1)\n&gt;&gt;&gt; out\narray([0.5, 2.5, 4.5, 6.5, 8.5])\n&gt;&gt;&gt; out = mean(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[4., 5.]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.median","title":"batcharray.computation.median","text":"<pre><code>median(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the median along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the medians are computed. The default (<code>None</code>) is to compute the median along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>A new array holding the result. If the input contains integers or floats smaller than <code>np.float64</code>, then the output data-type is <code>np.float64</code>. Otherwise, the data-type of the output is the same as that of the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import median\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = median(array, axis=0)\n&gt;&gt;&gt; out\narray([4., 5.])\n&gt;&gt;&gt; out = median(array, axis=1)\n&gt;&gt;&gt; out\narray([0.5, 2.5, 4.5, 6.5, 8.5])\n&gt;&gt;&gt; out = median(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[4., 5.]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.min","title":"batcharray.computation.min","text":"<pre><code>min(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the minimum along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the minimum values are computed. The default (<code>None</code>) is to compute the minimum along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>The minimum of the input array along the given axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import min\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = min(array, axis=0)\n&gt;&gt;&gt; out\narray([0, 1])\n&gt;&gt;&gt; out = min(array, axis=1)\n&gt;&gt;&gt; out\narray([0, 2, 4, 6, 8])\n&gt;&gt;&gt; out = min(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[0, 1]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.register_computation_models","title":"batcharray.computation.register_computation_models","text":"<pre><code>register_computation_models() -&gt; None\n</code></pre> <p>Register computation models to <code>AutoComputationModel</code>.</p> Example <pre><code>&gt;&gt;&gt; from batcharray.computation import AutoComputationModel, register_computation_models\n&gt;&gt;&gt; register_computation_models()\n&gt;&gt;&gt; comp_model = AutoComputationModel()\n&gt;&gt;&gt; comp_model\nAutoComputationModel(\n  ...\n)\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.sort","title":"batcharray.computation.sort","text":"<pre><code>sort(\n    arr: T,\n    axis: int | None = None,\n    *,\n    kind: SortKind | None = None\n) -&gt; T\n</code></pre> <p>Sort the elements of the input array along the given axis in ascending order by value.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which to sort. The default (<code>None</code>) is to sort along a flattened version of the array.</p> <code>None</code> <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>The sorted array along the given axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import sort\n&gt;&gt;&gt; array = np.array([[3, 5, 0, 2, 4], [4, 7, 8, 8, 5], [8, 5, 8, 8, 0]])\n&gt;&gt;&gt; out = sort(array, axis=0)\n&gt;&gt;&gt; out\narray([[3, 5, 0, 2, 0],\n       [4, 5, 8, 8, 4],\n       [8, 7, 8, 8, 5]])\n&gt;&gt;&gt; out = sort(array, axis=1)\n&gt;&gt;&gt; out\narray([[0, 2, 3, 4, 5],\n       [4, 5, 7, 8, 8],\n       [0, 5, 8, 8, 8]])\n</code></pre>"},{"location":"refs/constants/","title":"Constants","text":""},{"location":"refs/constants/#batcharray.constants","title":"batcharray.constants","text":"<p>Contain the important constants.</p>"},{"location":"refs/nested/","title":"nested","text":""},{"location":"refs/nested/#batcharray.nested","title":"batcharray.nested","text":"<p>Contain functions to manipulate nested data.</p>"},{"location":"refs/nested/#batcharray.nested.abs","title":"batcharray.nested.abs","text":"<pre><code>abs(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the absolute value of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The absolute value of the elements. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import abs\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[-4, -3], [-2, -1], [0, 1], [2, 3], [4, 5]]),\n...     \"b\": np.array([2, 1, 0, -1, -2]),\n... }\n&gt;&gt;&gt; out = abs(data)\n&gt;&gt;&gt; out\n{'a': array([[4, 3], [2, 1], [0, 1], [2, 3], [4, 5]]), 'b': array([2, 1, 0, 1, 2])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.amax_along_batch","title":"batcharray.nested.amax_along_batch","text":"<pre><code>amax_along_batch(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the maximum of all elements along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The maximum of all elements along the batch dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import amax_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = amax_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([8, 9]), 'b': np.int64(4)}\n&gt;&gt;&gt; out = amax_along_batch(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[8, 9]]), 'b': array([4])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.amax_along_seq","title":"batcharray.nested.amax_along_seq","text":"<pre><code>amax_along_seq(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the maximum of all elements along the sequence dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The maximum of all elements along the sequence dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import amax_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = amax_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([4, 9]), 'b': array([4])}\n&gt;&gt;&gt; out = amax_along_seq(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[4], [9]]), 'b': array([[4]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.amin_along_batch","title":"batcharray.nested.amin_along_batch","text":"<pre><code>amin_along_batch(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the minimum of all elements along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The minimum of all elements along the batch dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import amin_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = amin_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([0, 1]), 'b': np.int64(0)}\n&gt;&gt;&gt; out = amin_along_batch(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[0, 1]]), 'b': array([0])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.amin_along_seq","title":"batcharray.nested.amin_along_seq","text":"<pre><code>amin_along_seq(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the minimum of all elements along the sequence dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The minimum of all elements along the sequence dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import amin_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = amin_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([0, 5]), 'b': array([0])}\n&gt;&gt;&gt; out = amin_along_seq(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[0], [5]]), 'b': array([[0]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.arccos","title":"batcharray.nested.arccos","text":"<pre><code>arccos(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the inverse cosine of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The inverse cosine of the elements. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import arccos\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = arccos(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.arccosh","title":"batcharray.nested.arccosh","text":"<pre><code>arccosh(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the inverse hyperbolic cosine of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The inverse hyperbolic cosine of the elements. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import arccosh\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = arccosh(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.arcsin","title":"batcharray.nested.arcsin","text":"<pre><code>arcsin(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the arcsine of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The arcsine of the elements. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import arcsin\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = arcsin(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.arcsinh","title":"batcharray.nested.arcsinh","text":"<pre><code>arcsinh(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the inverse hyperbolic sine of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The inverse hyperbolic sine of the elements. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import arcsinh\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = arcsinh(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.arctan","title":"batcharray.nested.arctan","text":"<pre><code>arctan(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the arctangent of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The arctangent of the elements. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import arctan\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = arctan(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.arctanh","title":"batcharray.nested.arctanh","text":"<pre><code>arctanh(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the inverse hyperbolic tangent of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The inverse hyperbolic tangent of the elements. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import arctanh\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = arctanh(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.argmax_along_batch","title":"batcharray.nested.argmax_along_batch","text":"<pre><code>argmax_along_batch(\n    data: Any, keepdims: bool = False\n) -&gt; Any\n</code></pre> <p>Return the indices of the maximum value of all elements along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The indices of the maximum value of all elements along the batch dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import argmax_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = argmax_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([4, 4]), 'b': np.int64(0)}\n&gt;&gt;&gt; out = argmax_along_batch(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[4, 4]]), 'b': array([0])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.argmax_along_seq","title":"batcharray.nested.argmax_along_seq","text":"<pre><code>argmax_along_seq(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the indices of the maximum value of all elements along the sequence dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The indices of the maximum value of all elements along the sequence dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import argmax_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = argmax_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([4, 4]), 'b': array([0])}\n&gt;&gt;&gt; out = argmax_along_seq(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[4], [4]]), 'b': array([[0]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.argmin_along_batch","title":"batcharray.nested.argmin_along_batch","text":"<pre><code>argmin_along_batch(\n    data: Any, keepdims: bool = False\n) -&gt; Any\n</code></pre> <p>Return the indices of the minimum value of all elements along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The indices of the minimum value of all elements along the batch dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import argmin_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = argmin_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([0, 0]), 'b': np.int64(4)}\n&gt;&gt;&gt; out = argmin_along_batch(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[0, 0]]), 'b': array([4])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.argmin_along_seq","title":"batcharray.nested.argmin_along_seq","text":"<pre><code>argmin_along_seq(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the indices of the minimum value of all elements along the sequence dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The indices of the minimum value of all elements along the sequence dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import argmin_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = argmin_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([0, 0]), 'b': array([4])}\n&gt;&gt;&gt; out = argmin_along_seq(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[0], [0]]), 'b': array([[4]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.argsort_along_batch","title":"batcharray.nested.argsort_along_batch","text":"<pre><code>argsort_along_batch(\n    data: Any, kind: SortKind | None = None\n) -&gt; Any\n</code></pre> <p>Return the indices that sort each array along the batch dimension in ascending order by value.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The indices that sort each array along the batch dimension</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import argsort_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[2, 6], [0, 3], [4, 9], [8, 1], [5, 7]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = argsort_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([[1, 3], [0, 1], [2, 0], [4, 4], [3, 2]]), 'b': array([4, 3, 2, 1, 0])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.argsort_along_seq","title":"batcharray.nested.argsort_along_seq","text":"<pre><code>argsort_along_seq(\n    data: Any, kind: SortKind | None = None\n) -&gt; Any\n</code></pre> <p>Return the indices that sort each array along the sequence dimension in ascending order by value.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The indices that sort each array along the sequence dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import argsort_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[7, 3, 0, 8, 5], [1, 9, 6, 4, 2]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = argsort_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([[2, 1, 4, 0, 3], [0, 4, 3, 2, 1]]), 'b': array([[4, 3, 2, 1, 0]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.chunk_along_batch","title":"batcharray.nested.chunk_along_batch","text":"<pre><code>chunk_along_batch(\n    data: dict[Hashable, ndarray], chunks: int\n) -&gt; list[dict[Hashable, ndarray]]\n</code></pre> <p>Split all the arrays into chunks along the batch axis.</p> <p>Each chunk is a view of the input array.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[Hashable, ndarray]</code> <p>The input data. Each item must be an array.</p> required <code>chunks</code> <code>int</code> <p>Number of chunks to return.</p> required <p>Returns:</p> Type Description <code>list[dict[Hashable, ndarray]]</code> <p>The data chuncks.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import chunk_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; outputs = chunk_along_batch(data, chunks=3)\n&gt;&gt;&gt; outputs\n[{'a': array([[0, 1], [2, 3]]), 'b': array([4, 3])},\n {'a': array([[4, 5], [6, 7]]), 'b': array([2, 1])},\n {'a': array([[8, 9]]), 'b': array([0])}]\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.chunk_along_seq","title":"batcharray.nested.chunk_along_seq","text":"<pre><code>chunk_along_seq(\n    data: dict[Hashable, ndarray], chunks: int\n) -&gt; list[dict[Hashable, ndarray]]\n</code></pre> <p>Split all the arrays into chunks along the sequence axis.</p> <p>Each chunk is a view of the input array.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[Hashable, ndarray]</code> <p>The input data. Each item must be an array.</p> required <code>chunks</code> <code>int</code> <p>Number of chunks to return.</p> required <p>Returns:</p> Type Description <code>list[dict[Hashable, ndarray]]</code> <p>The data chunks.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import chunk_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; outputs = chunk_along_seq(data, chunks=3)\n&gt;&gt;&gt; outputs\n[{'a': array([[0, 1], [5, 6]]), 'b': array([[4, 3]])},\n {'a': array([[2, 3], [7, 8]]), 'b': array([[2, 1]])},\n {'a': array([[4], [9]]), 'b': array([[0]])}]\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.clip","title":"batcharray.nested.clip","text":"<pre><code>clip(\n    data: Any,\n    a_min: float | None = None,\n    a_max: float | None = None,\n) -&gt; Any\n</code></pre> <p>Clamp all elements in input into the range <code>[min, max]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <code>a_min</code> <code>float | None</code> <p>The lower-bound of the range to be clamped to.</p> <code>None</code> <code>a_max</code> <code>float | None</code> <p>The upper-bound of the range to be clamped to.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The clamp value of the elements. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import clip\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]),\n...     \"b\": np.array([5, 4, 3, 2, 1]),\n... }\n&gt;&gt;&gt; out = clip(data, a_min=1, a_max=5)\n&gt;&gt;&gt; out\n{'a': array([[1, 2], [3, 4], [5, 5], [5, 5], [5, 5]]), 'b': array([5, 4, 3, 2, 1])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.concatenate_along_batch","title":"batcharray.nested.concatenate_along_batch","text":"<pre><code>concatenate_along_batch(\n    data: Sequence[dict[Hashable, ndarray]],\n) -&gt; dict[Hashable, ndarray]\n</code></pre> <p>Concatenate the given arrays in the batch axis.</p> <p>All arrays must either have the same data type and shape (except in the concatenating axis) or be empty.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict[Hashable, ndarray]]</code> <p>The input data to concatenate. The dictionaries must have the same keys.</p> required <p>Returns:</p> Type Description <code>dict[Hashable, ndarray]</code> <p>The concatenated arrays along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import concatenate_along_batch\n&gt;&gt;&gt; data = [\n...     {\n...         \"a\": np.array([[0, 1, 2], [4, 5, 6]]),\n...         \"b\": np.array([[10, 11, 12], [13, 14, 15]]),\n...     },\n...     {\"a\": np.array([[7, 8, 9]]), \"b\": np.array([[17, 18, 19]])},\n... ]\n&gt;&gt;&gt; out = concatenate_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([[0, 1, 2], [4, 5, 6], [7, 8, 9]]),\n 'b': array([[10, 11, 12], [13, 14, 15], [17, 18, 19]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.concatenate_along_seq","title":"batcharray.nested.concatenate_along_seq","text":"<pre><code>concatenate_along_seq(\n    data: Sequence[dict[Hashable, ndarray]],\n) -&gt; dict[Hashable, ndarray]\n</code></pre> <p>Concatenate the given arrays in the sequence axis.</p> <p>All arrays must either have the same data type and shape (except in the concatenating axis) or be empty.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict[Hashable, ndarray]]</code> <p>The input data to concatenate. The dictionaries must have the same keys.</p> required <p>Returns:</p> Type Description <code>dict[Hashable, ndarray]</code> <p>The concatenated arrays along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import concatenate_along_seq\n&gt;&gt;&gt; data = [\n...     {\n...         \"a\": np.array([[0, 1, 2], [4, 5, 6]]),\n...         \"b\": np.array([[10, 11, 12], [13, 14, 15]]),\n...     },\n...     {\"a\": np.array([[7], [8]]), \"b\": np.array([[17], [18]])},\n... ]\n&gt;&gt;&gt; out = concatenate_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([[0, 1, 2, 7], [4, 5, 6, 8]]),\n 'b': array([[10, 11, 12, 17], [13, 14, 15, 18]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.cos","title":"batcharray.nested.cos","text":"<pre><code>cos(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the cosine of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The cosine of the elements. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import cos\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = cos(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.cosh","title":"batcharray.nested.cosh","text":"<pre><code>cosh(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the hyperbolic cosine of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The hyperbolic cosine of the elements. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import cosh\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = cosh(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.cumprod_along_batch","title":"batcharray.nested.cumprod_along_batch","text":"<pre><code>cumprod_along_batch(data: Any) -&gt; Any\n</code></pre> <p>Return the cumulative product of elements of input in the batch dimension.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The cumulative product of elements of input in the batch dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import cumprod_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = cumprod_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([[   1,    2], [   3,    8], [  15,   48], [ 105,  384], [ 945, 3840]]),\n 'b': array([ 4, 12, 24, 24,  0])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.cumprod_along_seq","title":"batcharray.nested.cumprod_along_seq","text":"<pre><code>cumprod_along_seq(data: Any) -&gt; Any\n</code></pre> <p>Return the cumulative product of elements of input in the sequence dimension.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The cumulative product of elements of input in the sequence dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import cumprod_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = cumprod_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([[    1,     2,     6,    24,   120], [    6,    42,   336,  3024, 30240]]),\n 'b': array([[ 4, 12, 24, 24,  0]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.cumsum_along_batch","title":"batcharray.nested.cumsum_along_batch","text":"<pre><code>cumsum_along_batch(data: Any) -&gt; Any\n</code></pre> <p>Return the cumulative sum of elements of input in the batch dimension.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The cumulative sum of elements of input in the batch dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import cumsum_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = cumsum_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([[ 0,  1], [ 2,  4], [ 6,  9], [12, 16], [20, 25]]),\n 'b': array([ 4,  7,  9, 10, 10])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.cumsum_along_seq","title":"batcharray.nested.cumsum_along_seq","text":"<pre><code>cumsum_along_seq(data: Any) -&gt; Any\n</code></pre> <p>Return the cumulative sum of elements of input in the sequence dimension.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The cumulative sum of elements of input in the sequence dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import cumsum_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = cumsum_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([[ 0,  1,  3,  6, 10], [ 5, 11, 18, 26, 35]]),\n 'b': array([[ 4,  7,  9, 10, 10]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.exp","title":"batcharray.nested.exp","text":"<pre><code>exp(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the exponential of the elements.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The exponential of the elements. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import exp\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]),\n...     \"b\": np.array([5, 4, 3, 2, 1]),\n... }\n&gt;&gt;&gt; out = exp(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.exp2","title":"batcharray.nested.exp2","text":"<pre><code>exp2(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the base two exponential of the elements.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The base two exponential of the elements. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import exp2\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]),\n...     \"b\": np.array([5, 4, 3, 2, 1]),\n... }\n&gt;&gt;&gt; out = exp2(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.expm1","title":"batcharray.nested.expm1","text":"<pre><code>expm1(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the exponential of the elements minus 1.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The exponential of the elements minus 1. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import expm1\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]),\n...     \"b\": np.array([5, 4, 3, 2, 1]),\n... }\n&gt;&gt;&gt; out = expm1(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.index_select_along_batch","title":"batcharray.nested.index_select_along_batch","text":"<pre><code>index_select_along_batch(\n    data: Any, indices: ndarray\n) -&gt; Any\n</code></pre> <p>Return the arrays which index the arrays along the batch axis using the entries in <code>indices</code>.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> Note <p>Equivalent to <code>take_along_batch</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>indices</code> <code>ndarray</code> <p>The 1-D array containing the indices to take.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The indexed arrays along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import index_select_along_batch\n&gt;&gt;&gt; arrays = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = index_select_along_batch(arrays, np.array([2, 4]))\n&gt;&gt;&gt; out\n{'a': array([[4, 5], [8, 9]]), 'b': array([2, 0])}\n&gt;&gt;&gt; out = index_select_along_batch(arrays, np.array([4, 3, 2, 1, 0]))\n&gt;&gt;&gt; out\n{'a': array([[8, 9], [6, 7], [4, 5], [2, 3], [0, 1]]), 'b': array([0, 1, 2, 3, 4])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.index_select_along_seq","title":"batcharray.nested.index_select_along_seq","text":"<pre><code>index_select_along_seq(data: Any, indices: ndarray) -&gt; Any\n</code></pre> <p>Return the arrays which index the arrays along the sequence axis using the entries in <code>indices</code>.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> Note <p>Equivalent to <code>take_along_seq</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>indices</code> <code>ndarray</code> <p>The 1-D array containing the indices to take.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The indexed arrays along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import index_select_along_seq\n&gt;&gt;&gt; arrays = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = index_select_along_seq(arrays, np.array([2, 4]))\n&gt;&gt;&gt; out\n{'a': array([[2, 4], [7, 9]]), 'b': array([[2, 0]])}\n&gt;&gt;&gt; out = index_select_along_seq(arrays, np.array([4, 3, 2, 1, 0]))\n&gt;&gt;&gt; out\n{'a': array([[4, 3, 2, 1, 0], [9, 8, 7, 6, 5]]), 'b': array([[0, 1, 2, 3, 4]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.log","title":"batcharray.nested.log","text":"<pre><code>log(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the natural logarithm of the elements.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The natural logarithm of the elements. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import log\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]),\n...     \"b\": np.array([5, 4, 3, 2, 1]),\n... }\n&gt;&gt;&gt; out = log(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.log10","title":"batcharray.nested.log10","text":"<pre><code>log10(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the logarithm to the base 10 of the elements.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The with the logarithm to the base 10 of the elements. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import log10\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]),\n...     \"b\": np.array([5, 4, 3, 2, 1]),\n... }\n&gt;&gt;&gt; out = log10(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.log1p","title":"batcharray.nested.log1p","text":"<pre><code>log1p(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the natural logarithm of <code>(1 + input)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The natural logarithm of <code>(1 + input)</code>. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import log1p\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]),\n...     \"b\": np.array([5, 4, 3, 2, 1]),\n... }\n&gt;&gt;&gt; out = log1p(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.log2","title":"batcharray.nested.log2","text":"<pre><code>log2(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the logarithm to the base 2 of the elements.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The logarithm to the base 2 of the elements. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import log2\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]),\n...     \"b\": np.array([5, 4, 3, 2, 1]),\n... }\n&gt;&gt;&gt; out = log2(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.masked_select_along_batch","title":"batcharray.nested.masked_select_along_batch","text":"<pre><code>masked_select_along_batch(data: Any, mask: ndarray) -&gt; Any\n</code></pre> <p>Return the arrays which index the arrays along the batch axis according to the boolean mask <code>mask</code>.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>mask</code> <code>ndarray</code> <p>The 1-D array containing the binary mask to index with.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The indexed arrays along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import masked_select_along_batch\n&gt;&gt;&gt; arrays = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = masked_select_along_batch(arrays, np.array([False, False, True, False, True]))\n&gt;&gt;&gt; out\n{'a': array([[4, 5], [8, 9]]), 'b': array([2, 0])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.masked_select_along_seq","title":"batcharray.nested.masked_select_along_seq","text":"<pre><code>masked_select_along_seq(data: Any, mask: ndarray) -&gt; Any\n</code></pre> <p>Return the arrays which index the arrays along the sequence axis according to the boolean mask <code>mask</code>.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>mask</code> <code>ndarray</code> <p>The 1-D array containing the binary mask to index with.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The indexed arrays along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import masked_select_along_seq\n&gt;&gt;&gt; arrays = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = masked_select_along_seq(arrays, np.array([False, False, True, False, True]))\n&gt;&gt;&gt; out\n{'a': array([[2, 4], [7, 9]]), 'b': array([[2, 0]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.max_along_batch","title":"batcharray.nested.max_along_batch","text":"<pre><code>max_along_batch(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the maximum of all elements along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The maximum of all elements along the batch dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import max_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = max_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([8, 9]), 'b': np.int64(4)}\n&gt;&gt;&gt; out = max_along_batch(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[8, 9]]), 'b': array([4])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.max_along_seq","title":"batcharray.nested.max_along_seq","text":"<pre><code>max_along_seq(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the maximum of all elements along the sequence dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The maximum of all elements along the sequence dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import max_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = max_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([4, 9]), 'b': array([4])}\n&gt;&gt;&gt; out = max_along_seq(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[4], [9]]), 'b': array([[4]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.mean_along_batch","title":"batcharray.nested.mean_along_batch","text":"<pre><code>mean_along_batch(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the mean of all elements along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The mean of all elements along the batch dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import mean_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0.0, 1.0], [2.0, 3.0], [4.0, 5.0], [6.0, 7.0], [8.0, 9.0]]),\n...     \"b\": np.array([4, 3, 2, 1, 0], dtype=np.float32),\n... }\n&gt;&gt;&gt; out = mean_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([4., 5.]), 'b': np.float32(2.0)}\n&gt;&gt;&gt; out = mean_along_batch(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[4., 5.]]), 'b': array([2.], dtype=float32)}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.mean_along_seq","title":"batcharray.nested.mean_along_seq","text":"<pre><code>mean_along_seq(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the mean of all elements along the sequence dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The mean of all elements along the sequence dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import mean_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0.0, 1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0, 9.0]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]], dtype=np.float32),\n... }\n&gt;&gt;&gt; out = mean_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([2., 7.]), 'b': array([2.], dtype=float32)}\n&gt;&gt;&gt; out = mean_along_seq(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[2.], [7.]]), 'b': array([[2.]], dtype=float32)}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.median_along_batch","title":"batcharray.nested.median_along_batch","text":"<pre><code>median_along_batch(\n    data: Any, keepdims: bool = False\n) -&gt; Any\n</code></pre> <p>Return the median of all elements along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>A new array holding the result. If the input contains integers or floats smaller than <code>np.float64</code>, then the output data-type is <code>np.float64</code>. Otherwise, the data-type of the output is the same as that of the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import median_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = median_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([4., 5.]), 'b': np.float64(2.0)}\n&gt;&gt;&gt; out = median_along_batch(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[4., 5.]]), 'b': array([2.])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.median_along_seq","title":"batcharray.nested.median_along_seq","text":"<pre><code>median_along_seq(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the median of all elements along the sequence dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>A new array holding the result. If the input contains integers or floats smaller than <code>np.float64</code>, then the output data-type is <code>np.float64</code>. Otherwise, the data-type of the output is the same as that of the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import median_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = median_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([2., 7.]), 'b': array([2.])}\n&gt;&gt;&gt; out = median_along_seq(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[2.], [7.]]), 'b': array([[2.]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.min_along_batch","title":"batcharray.nested.min_along_batch","text":"<pre><code>min_along_batch(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the minimum of all elements along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The minimum of all elements along the batch dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import min_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = min_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([0, 1]), 'b': np.int64(0)}\n&gt;&gt;&gt; out = min_along_batch(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[0, 1]]), 'b': array([0])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.min_along_seq","title":"batcharray.nested.min_along_seq","text":"<pre><code>min_along_seq(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the minimum of all elements along the sequence dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The minimum of all elements along the sequence dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import min_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = min_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([0, 5]), 'b': array([0])}\n&gt;&gt;&gt; out = min_along_seq(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[0], [5]]), 'b': array([[0]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.permute_along_batch","title":"batcharray.nested.permute_along_batch","text":"<pre><code>permute_along_batch(data: Any, permutation: ndarray) -&gt; Any\n</code></pre> <p>Permute all the arrays along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>permutation</code> <code>ndarray</code> <p>The 1-D array containing the indices of the permutation. The shape should match the batch axis of the array.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The data with permuted arrays along the batch axis. The output data has the same structure as the input data.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the shape of the permutation does not match the batch axis of the array.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import permute_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = permute_along_batch(data, np.array([2, 1, 3, 0, 4]))\n&gt;&gt;&gt; out\n{'a': array([[4, 5], [2, 3], [6, 7], [0, 1], [8, 9]]), 'b': array([2, 3, 1, 4, 0])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.permute_along_seq","title":"batcharray.nested.permute_along_seq","text":"<pre><code>permute_along_seq(data: Any, permutation: ndarray) -&gt; Any\n</code></pre> <p>Permute all the arrays along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>permutation</code> <code>ndarray</code> <p>The 1-D array containing the indices of the permutation. The shape should match the sequence axis of the array.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The data with permuted arrays along the sequence axis. The output data has the same structure as the input data.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the shape of the permutation does not match the sequence axis of the array.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import permute_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = permute_along_seq(data, np.array([2, 1, 3, 0, 4]))\n&gt;&gt;&gt; out\n{'a': array([[2, 1, 3, 0, 4], [7, 6, 8, 5, 9]]), 'b': array([[2, 3, 1, 4, 0]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.prod_along_batch","title":"batcharray.nested.prod_along_batch","text":"<pre><code>prod_along_batch(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the product of all elements along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The product of all elements along the batch dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import prod_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([5, 4, 3, 2, 1]),\n... }\n&gt;&gt;&gt; out = prod_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([  0, 945]), 'b': np.int64(120)}\n&gt;&gt;&gt; out = prod_along_batch(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[  0, 945]]), 'b': array([120])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.prod_along_seq","title":"batcharray.nested.prod_along_seq","text":"<pre><code>prod_along_seq(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the product of all elements along the sequence dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The product of all elements along the sequence dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import prod_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[5, 4, 3, 2, 1]]),\n... }\n&gt;&gt;&gt; out = prod_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([    0, 15120]), 'b': array([120])}\n&gt;&gt;&gt; out = prod_along_seq(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[    0], [15120]]), 'b': array([[120]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.select_along_batch","title":"batcharray.nested.select_along_batch","text":"<pre><code>select_along_batch(data: Any, index: int) -&gt; Any\n</code></pre> <p>Slice the arrays along the batch axis at the given index.</p> <p>This function returns a view of the original array with the batch axis removed.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>index</code> <code>int</code> <p>The index to select with.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The sliced arrays along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import select_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = select_along_batch(data, index=2)\n&gt;&gt;&gt; out\n{'a': array([4, 5]), 'b': np.int64(2)}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.select_along_seq","title":"batcharray.nested.select_along_seq","text":"<pre><code>select_along_seq(data: Any, index: int) -&gt; Any\n</code></pre> <p>Slice the arrays along the sequence axis at the given index.</p> <p>This function returns a view of the original array with the sequence axis removed.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>index</code> <code>int</code> <p>The index to select with.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The sliced arrays along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import select_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = select_along_seq(data, index=2)\n&gt;&gt;&gt; out\n{'a': array([2, 7]), 'b': array([2])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.shuffle_along_batch","title":"batcharray.nested.shuffle_along_batch","text":"<pre><code>shuffle_along_batch(\n    data: Any, rng: Generator | None = None\n) -&gt; Any\n</code></pre> <p>Shuffle all the arrays along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>rng</code> <code>Generator | None</code> <p>An optional random number generator.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The data with shuffled arrays along the sequence axis. The output data has the same structure as the input data.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import shuffle_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = shuffle_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.shuffle_along_seq","title":"batcharray.nested.shuffle_along_seq","text":"<pre><code>shuffle_along_seq(\n    data: Any, rng: Generator | None = None\n) -&gt; Any\n</code></pre> <p>Shuffle all the arrays along the batch axis.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>rng</code> <code>Generator | None</code> <p>An optional random number generator.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The data with shuffled arrays along the sequence axis. The output data has the same structure as the input data.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import shuffle_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = shuffle_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([[...]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.sin","title":"batcharray.nested.sin","text":"<pre><code>sin(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the sine of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The sine of the elements. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import sin\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = sin(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.sinh","title":"batcharray.nested.sinh","text":"<pre><code>sinh(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the hyperbolic sine of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The hyperbolic sine of the elements. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import sinh\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = sinh(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.slice_along_batch","title":"batcharray.nested.slice_along_batch","text":"<pre><code>slice_along_batch(\n    data: Any,\n    start: int = 0,\n    stop: int | None = None,\n    step: int = 1,\n) -&gt; Any\n</code></pre> <p>Slice all the arrays along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>start</code> <code>int</code> <p>The index where the slicing of object starts.</p> <code>0</code> <code>stop</code> <code>int | None</code> <p>The index where the slicing of object stops. <code>None</code> means last.</p> <code>None</code> <code>step</code> <code>int</code> <p>The increment between each index for slicing.</p> <code>1</code> <p>Returns:</p> Type Description <code>Any</code> <p>The sliced arrays along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import slice_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = slice_along_batch(data, start=2)\n&gt;&gt;&gt; out\n{'a': array([[4, 5], [6, 7], [8, 9]]), 'b': array([2, 1, 0])}\n&gt;&gt;&gt; out = slice_along_batch(data, stop=3)\n&gt;&gt;&gt; out\n{'a': array([[0, 1], [2, 3], [4, 5]]), 'b': array([4, 3, 2])}\n&gt;&gt;&gt; out = slice_along_batch(data, step=2)\n&gt;&gt;&gt; out\n{'a': array([[0, 1], [4, 5], [8, 9]]), 'b': array([4, 2, 0])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.slice_along_seq","title":"batcharray.nested.slice_along_seq","text":"<pre><code>slice_along_seq(\n    data: Any,\n    start: int = 0,\n    stop: int | None = None,\n    step: int = 1,\n) -&gt; Any\n</code></pre> <p>Slice all the arrays along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>start</code> <code>int</code> <p>The index where the slicing of object starts.</p> <code>0</code> <code>stop</code> <code>int | None</code> <p>The index where the slicing of object stops. <code>None</code> means last.</p> <code>None</code> <code>step</code> <code>int</code> <p>The increment between each index for slicing.</p> <code>1</code> <p>Returns:</p> Type Description <code>Any</code> <p>The sliced arrays along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import slice_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = slice_along_seq(data, start=2)\n&gt;&gt;&gt; out\n{'a': array([[2, 3, 4], [7, 8, 9]]), 'b': array([[2, 1, 0]])}\n&gt;&gt;&gt; out = slice_along_seq(data, stop=3)\n&gt;&gt;&gt; out\n{'a': array([[0, 1, 2], [5, 6, 7]]), 'b': array([[4, 3, 2]])}\n&gt;&gt;&gt; out = slice_along_seq(data, step=2)\n&gt;&gt;&gt; out\n{'a': array([[0, 2, 4], [5, 7, 9]]), 'b': array([[4, 2, 0]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.sort_along_batch","title":"batcharray.nested.sort_along_batch","text":"<pre><code>sort_along_batch(\n    data: Any, kind: SortKind | None = None\n) -&gt; Any\n</code></pre> <p>Sort the elements of the input array along the batch dimension in ascending order by value.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>A similar object where each array is replaced by a sorted array along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import sort_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[2, 6], [0, 3], [4, 9], [8, 1], [5, 7]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = sort_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([[0, 1], [2, 3], [4, 6], [5, 7], [8, 9]]), 'b': array([0, 1, 2, 3, 4])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.sort_along_seq","title":"batcharray.nested.sort_along_seq","text":"<pre><code>sort_along_seq(\n    data: Any, kind: SortKind | None = None\n) -&gt; Any\n</code></pre> <p>Sort the elements of the input array along the sequence dimension in ascending order by value.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>A similar object where each array is replaced by a sorted array along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import sort_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[7, 3, 0, 8, 5], [1, 9, 6, 4, 2]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = sort_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([[0, 3, 5, 7, 8], [1, 2, 4, 6, 9]]), 'b': array([[0, 1, 2, 3, 4]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.split_along_batch","title":"batcharray.nested.split_along_batch","text":"<pre><code>split_along_batch(\n    data: dict[Hashable, ndarray],\n    split_size_or_sections: int | Sequence[int],\n) -&gt; list[dict[Hashable, ndarray]]\n</code></pre> <p>Split all the arrays into chunks along the batch axis.</p> <p>Each chunk is a view of the original array.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[Hashable, ndarray]</code> <p>The input data. Each item must be an array.</p> required <code>split_size_or_sections</code> <code>int | Sequence[int]</code> <p>Size of a single chunk or list of sizes for each chunk</p> required <p>Returns:</p> Type Description <code>list[dict[Hashable, ndarray]]</code> <p>The data chunks.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import split_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; outputs = split_along_batch(data, split_size_or_sections=2)\n&gt;&gt;&gt; outputs\n[{'a': array([[0, 1], [2, 3]]), 'b': array([4, 3])},\n {'a': array([[4, 5], [6, 7]]), 'b': array([2, 1])},\n {'a': array([[8, 9]]), 'b': array([0])}]\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.split_along_seq","title":"batcharray.nested.split_along_seq","text":"<pre><code>split_along_seq(\n    data: dict[Hashable, ndarray],\n    split_size_or_sections: int | Sequence[int],\n) -&gt; list[dict[Hashable, ndarray]]\n</code></pre> <p>Split all the arrays into chunks along the sequence axis.</p> <p>Each chunk is a view of the original array.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[Hashable, ndarray]</code> <p>The input data. Each item must be an array.</p> required <code>split_size_or_sections</code> <code>int | Sequence[int]</code> <p>Size of a single chunk or list of sizes for each chunk</p> required <p>Returns:</p> Type Description <code>list[dict[Hashable, ndarray]]</code> <p>The data chunks.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import split_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; outputs = split_along_seq(data, split_size_or_sections=2)\n&gt;&gt;&gt; outputs\n[{'a': array([[0, 1], [5, 6]]), 'b': array([[4, 3]])},\n {'a': array([[2, 3], [7, 8]]), 'b': array([[2, 1]])},\n {'a': array([[4], [9]]), 'b': array([[0]])}]\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.sum_along_batch","title":"batcharray.nested.sum_along_batch","text":"<pre><code>sum_along_batch(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the sum of all elements along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The sum of all elements along the batch dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import sum_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = sum_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([20, 25]), 'b': np.int64(10)}\n&gt;&gt;&gt; out = sum_along_batch(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[20, 25]]), 'b': array([10])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.sum_along_seq","title":"batcharray.nested.sum_along_seq","text":"<pre><code>sum_along_seq(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the sum of all elements along the sequence dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The sum of all elements along the sequence dimension.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import sum_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = sum_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([10, 35]), 'b': array([10])}\n&gt;&gt;&gt; out = sum_along_seq(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[10], [35]]), 'b': array([[10]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.take_along_batch","title":"batcharray.nested.take_along_batch","text":"<pre><code>take_along_batch(data: Any, indices: ndarray) -&gt; Any\n</code></pre> <p>Return the arrays which index the arrays along the batch axis using the entries in <code>indices</code>.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> Note <p>Equivalent to <code>index_select_along_batch</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>indices</code> <code>ndarray</code> <p>The 1-D array containing the indices to take.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The indexed arrays along the batch axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import take_along_batch\n&gt;&gt;&gt; arrays = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = take_along_batch(arrays, np.array([2, 4]))\n&gt;&gt;&gt; out\n{'a': array([[4, 5], [8, 9]]), 'b': array([2, 0])}\n&gt;&gt;&gt; out = take_along_batch(arrays, np.array([4, 3, 2, 1, 0]))\n&gt;&gt;&gt; out\n{'a': array([[8, 9], [6, 7], [4, 5], [2, 3], [0, 1]]), 'b': array([0, 1, 2, 3, 4])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.take_along_seq","title":"batcharray.nested.take_along_seq","text":"<pre><code>take_along_seq(data: Any, indices: ndarray) -&gt; Any\n</code></pre> <p>Return the arrays which index the arrays along the sequence axis using the entries in <code>indices</code>.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> Note <p>Equivalent to <code>index_select_along_seq</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>indices</code> <code>ndarray</code> <p>The 1-D array containing the indices to take.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The indexed arrays along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import take_along_seq\n&gt;&gt;&gt; arrays = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = take_along_seq(arrays, np.array([2, 4]))\n&gt;&gt;&gt; out\n{'a': array([[2, 4], [7, 9]]), 'b': array([[2, 0]])}\n&gt;&gt;&gt; out = take_along_seq(arrays, np.array([4, 3, 2, 1, 0]))\n&gt;&gt;&gt; out\n{'a': array([[4, 3, 2, 1, 0], [9, 8, 7, 6, 5]]), 'b': array([[0, 1, 2, 3, 4]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.tan","title":"batcharray.nested.tan","text":"<pre><code>tan(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the tangent of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The tangent of the elements. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import tan\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = tan(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.tanh","title":"batcharray.nested.tanh","text":"<pre><code>tanh(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the hyperbolic tangent of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The hyperbolic tangent of the elements. The output has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import tanh\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = tanh(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.tile_along_seq","title":"batcharray.nested.tile_along_seq","text":"<pre><code>tile_along_seq(data: Any, reps: int) -&gt; Any\n</code></pre> <p>Repeat all the arrays along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>reps</code> <code>int</code> <p>The number of repetitions data along the sequence axis.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The arrays repeated along the sequence axis.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import tile_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = tile_along_seq(data, 2)\n&gt;&gt;&gt; out\n{'a': array([[0, 1, 2, 3, 4, 0, 1, 2, 3, 4], [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]]),\n 'b': array([[4, 3, 2, 1, 0, 4, 3, 2, 1, 0]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.to_list","title":"batcharray.nested.to_list","text":"<pre><code>to_list(data: Any) -&gt; Any\n</code></pre> <p>Create a new nested data structure where the <code>numpy.ndarray</code>s are converted to lists.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a <code>numpy.ndarray</code>.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>A nested data structure with lists instead of <code>numpy.ndarray</code>s. The output data has the same structure as the input.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import to_list\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 5)), \"b\": np.array([0, 1, 2, 3, 4])}\n&gt;&gt;&gt; out = to_list(data)\n&gt;&gt;&gt; out\n{'a': [[1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0]], 'b': [0, 1, 2, 3, 4]}\n</code></pre>"},{"location":"refs/types/","title":"Types","text":""},{"location":"refs/types/#batcharray.types","title":"batcharray.types","text":"<p>Contain types used in the remaining of the package.</p>"},{"location":"tutorials/batches/","title":"Tutorial: Working with Batches","text":"<p>This tutorial will guide you through the basics of working with batches of data using <code>batcharray</code>.</p>"},{"location":"tutorials/batches/#introduction","title":"Introduction","text":"<p>In machine learning and data processing, we often work with batches of data - collections of samples processed together. <code>batcharray</code> provides convenient utilities to manipulate these batches, whether they're single arrays or complex nested structures.</p>"},{"location":"tutorials/batches/#basic-batch-operations","title":"Basic Batch Operations","text":""},{"location":"tutorials/batches/#creating-a-batch","title":"Creating a Batch","text":"<p>Let's start by creating a simple batch of data:</p> <pre><code>import numpy as np\nfrom batcharray import array\n\n# Create a batch of 5 samples, each with 3 features\nbatch = np.array(\n    [\n        [1.0, 2.0, 3.0],\n        [4.0, 5.0, 6.0],\n        [7.0, 8.0, 9.0],\n        [10.0, 11.0, 12.0],\n        [13.0, 14.0, 15.0],\n    ]\n)\n</code></pre>"},{"location":"tutorials/batches/#slicing-batches","title":"Slicing Batches","text":"<p>You can extract a subset of samples from a batch:</p> <p>```python continuation</p>"},{"location":"tutorials/batches/#create-a-batch-of-5-samples-each-with-3-features","title":"Create a batch of 5 samples, each with 3 features","text":"<p>batch = np.array(     [         [1.0, 2.0, 3.0],         [4.0, 5.0, 6.0],         [7.0, 8.0, 9.0],         [10.0, 11.0, 12.0],         [13.0, 14.0, 15.0],     ] )</p>"},{"location":"tutorials/batches/#get-first-3-samples","title":"Get first 3 samples","text":"<p>first_three = array.slice_along_batch(batch, stop=3)</p>"},{"location":"tutorials/batches/#1-2-3","title":"[[1. 2. 3.]","text":""},{"location":"tutorials/batches/#4-5-6","title":"[4. 5. 6.]","text":""},{"location":"tutorials/batches/#7-8-9","title":"[7. 8. 9.]]","text":""},{"location":"tutorials/batches/#get-samples-2-4-indices-1-2-3","title":"Get samples 2-4 (indices 1, 2, 3)","text":"<p>middle_samples = array.slice_along_batch(batch, start=1, stop=4)</p>"},{"location":"tutorials/batches/#4-5-6_1","title":"[[ 4.  5.  6.]","text":""},{"location":"tutorials/batches/#7-8-9_1","title":"[ 7.  8.  9.]","text":""},{"location":"tutorials/batches/#10-11-12","title":"[10. 11. 12.]]","text":""},{"location":"tutorials/batches/#get-last-2-samples","title":"Get last 2 samples","text":"<p>last_two = array.slice_along_batch(batch, start=3)</p>"},{"location":"tutorials/batches/#10-11-12_1","title":"[[10. 11. 12.]","text":""},{"location":"tutorials/batches/#13-14-15","title":"[13. 14. 15.]]","text":"<pre><code>### Selecting Specific Samples\n\nUse `index_select_along_batch` to select specific samples by index:\n\n```python continuation\n# Select samples at indices 0, 2, and 4\nindices = np.array([0, 2, 4])\nselected = array.index_select_along_batch(batch, indices=indices)\n# [[ 1.  2.  3.]\n#  [ 7.  8.  9.]\n#  [13. 14. 15.]]\n</code></pre>"},{"location":"tutorials/batches/#splitting-batches","title":"Splitting Batches","text":"<p>Split a batch into multiple smaller batches:</p> <p>```python continuation</p>"},{"location":"tutorials/batches/#split-into-batches-of-size-2","title":"Split into batches of size 2","text":"<p>chunks = array.chunk_along_batch(batch, chunks=3)</p>"},{"location":"tutorials/batches/#array1-2-3-4-5-6","title":"[array([[1., 2., 3.], [4., 5., 6.]]),","text":""},{"location":"tutorials/batches/#array-7-8-9-10-11-12","title":"array([[ 7.,  8.,  9.], [10., 11., 12.]]),","text":""},{"location":"tutorials/batches/#array13-14-15","title":"array([[13., 14., 15.]])]","text":""},{"location":"tutorials/batches/#split-at-specific-sizes","title":"Split at specific sizes","text":"<p>splits = array.split_along_batch(batch, split_size_or_sections=[2, 2, 1])</p>"},{"location":"tutorials/batches/#array1-2-3-4-5-6_1","title":"[array([[1., 2., 3.], [4., 5., 6.]]),","text":""},{"location":"tutorials/batches/#array-7-8-9-10-11-12_1","title":"array([[ 7.,  8.,  9.], [10., 11., 12.]]),","text":""},{"location":"tutorials/batches/#array13-14-15_1","title":"array([[13., 14., 15.]])]","text":"<pre><code>## Working with Nested Batches\n\nReal-world data often comes in nested structures - dictionaries with multiple arrays, lists of\narrays, etc.\n\n### Dictionary Batches\n\n```python\nimport numpy as np\nfrom batcharray import nested\n\n# Create a batch as a dictionary\nbatch = {\n    \"features\": np.array(\n        [\n            [1.0, 2.0, 3.0],\n            [4.0, 5.0, 6.0],\n            [7.0, 8.0, 9.0],\n        ]\n    ),\n    \"labels\": np.array([0, 1, 0]),\n    \"weights\": np.array([1.0, 0.8, 1.2]),\n}\n\n# Slice all arrays together\ntrain_batch = nested.slice_along_batch(batch, stop=2)\n# {\n#     'features': array([[1., 2., 3.],\n#                        [4., 5., 6.]]),\n#     'labels': array([0, 1]),\n#     'weights': array([1. , 0.8])\n# }\n\n# Split into train/validation\nsplits = nested.split_along_batch(batch, split_size_or_sections=[2, 1])\ntrain, val = splits[0], splits[1]\n</code></pre>"},{"location":"tutorials/batches/#maintaining-consistency","title":"Maintaining Consistency","text":"<p>The key advantage of <code>nested</code> operations is that they maintain consistency across all arrays:</p> <pre><code>import numpy as np\nfrom batcharray import nested\n\n# Shuffle while keeping features and labels aligned\nbatch = {\"features\": np.array([[1, 2], [3, 4], [5, 6]]), \"labels\": np.array([0, 1, 0])}\n\nshuffled = nested.shuffle_along_batch(batch)\n# Features and labels are shuffled with the same permutation\n</code></pre>"},{"location":"tutorials/batches/#computing-statistics","title":"Computing Statistics","text":""},{"location":"tutorials/batches/#batch-level-statistics","title":"Batch-level Statistics","text":"<p>Compute statistics across samples in a batch:</p> <pre><code>import numpy as np\nfrom batcharray import array\n\ndata = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])\n\n# Mean across samples (for each feature)\nmean_features = array.mean_along_batch(data)\n# [4. 5. 6.]\n\n# Maximum value for each feature\nmax_features = array.amax_along_batch(data)\n# [7. 8. 9.]\n\n# Sum across samples\nsum_features = array.sum_along_batch(data)\n# [12. 15. 18.]\n</code></pre>"},{"location":"tutorials/batches/#finding-extremes","title":"Finding Extremes","text":"<pre><code>import numpy as np\nfrom batcharray import array\n\nscores = np.array([[0.2, 0.5, 0.3], [0.1, 0.8, 0.1], [0.6, 0.2, 0.2]])\n\n# Index of maximum value for each feature\nmax_indices = array.argmax_along_batch(scores)\n# [2, 1, 0]\n\n# Actual maximum values\nmax_values = array.amax_along_batch(scores)\n# [0.6, 0.8, 0.3]\n</code></pre>"},{"location":"tutorials/batches/#sorting-and-ordering","title":"Sorting and Ordering","text":""},{"location":"tutorials/batches/#sorting-batches","title":"Sorting Batches","text":"<pre><code>import numpy as np\nfrom batcharray import array\n\n# Unsorted batch\ndata = np.array([[5, 2], [1, 4], [3, 6]])\n\n# Sort along batch dimension\nsorted_data = array.sort_along_batch(data)\n# [[1 2]\n#  [3 4]\n#  [5 6]]\n\n# Get sorting indices\nsort_indices = array.argsort_along_batch(data)\n# [[1 0]\n#  [2 1]\n#  [0 2]]\n</code></pre>"},{"location":"tutorials/batches/#random-shuffling","title":"Random Shuffling","text":"<pre><code>import numpy as np\nfrom batcharray import array\n\ndata = np.array([[1, 2], [3, 4], [5, 6]])\n\n# Random shuffle\nshuffled = array.shuffle_along_batch(data)\n# Order is randomized, e.g.:\n# [[5 6]\n#  [1 2]\n#  [3 4]]\n</code></pre>"},{"location":"tutorials/batches/#combining-batches","title":"Combining Batches","text":""},{"location":"tutorials/batches/#concatenation","title":"Concatenation","text":"<pre><code>import numpy as np\nfrom batcharray import array\n\nbatch1 = np.array([[1, 2], [3, 4]])\nbatch2 = np.array([[5, 6], [7, 8]])\n\n# Combine batches\ncombined = array.concatenate_along_batch([batch1, batch2])\n# [[1 2]\n#  [3 4]\n#  [5 6]\n#  [7 8]]\n</code></pre>"},{"location":"tutorials/batches/#nested-concatenation","title":"Nested Concatenation","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\nbatch1 = {\"features\": np.array([[1, 2], [3, 4]]), \"labels\": np.array([0, 1])}\n\nbatch2 = {\"features\": np.array([[5, 6]]), \"labels\": np.array([0])}\n\ncombined = nested.concatenate_along_batch([batch1, batch2])\n# {\n#     'features': array([[1, 2],\n#                        [3, 4],\n#                        [5, 6]]),\n#     'labels': array([0, 1, 0])\n# }\n</code></pre>"},{"location":"tutorials/batches/#working-with-missing-data","title":"Working with Missing Data","text":"<p>NumPy masked arrays allow you to handle missing or invalid data:</p> <pre><code>import numpy as np\nimport numpy.ma as ma\nfrom batcharray import array\n\n# Create data with missing values (marked as masked)\ndata = ma.array(\n    [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]],\n    mask=[\n        [False, True, False],  # 2nd value missing\n        [False, False, True],  # 3rd value missing\n        [True, False, False],\n    ],  # 1st value missing\n)\n\n# Compute mean (ignoring masked values)\nmean_vals = array.mean_along_batch(data)\n# [2.5, 5.0, 4.5]\n\n# Sort (masked values handled appropriately)\nsorted_data = array.sort_along_batch(data)\n# [[1.0 5.0 3.0]\n#  [4.0 8.0 9.0]\n#  [-- -- --]]\n</code></pre>"},{"location":"tutorials/batches/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about sequence operations for time-series data</li> <li>Explore advanced nested operations</li> <li>See computation models for low-level operations</li> <li>Check the FAQ for common questions</li> </ul>"},{"location":"tutorials/batches/#common-patterns","title":"Common Patterns","text":""},{"location":"tutorials/batches/#traintest-split","title":"Train/Test Split","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\n# Full dataset\ndataset = {\n    \"X\": np.random.randn(1000, 784),  # MNIST-like\n    \"y\": np.random.randint(0, 10, 1000),\n}\n\n# 80/20 split\ntrain_size = int(0.8 * 1000)\ntrain_data = nested.slice_along_batch(dataset, stop=train_size)\ntest_data = nested.slice_along_batch(dataset, start=train_size)\n</code></pre>"},{"location":"tutorials/batches/#mini-batch-processing","title":"Mini-batch Processing","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\n# Large dataset\ndataset = {\"X\": np.random.randn(1000, 10), \"y\": np.random.randint(0, 2, 1000)}\n\n# Process in mini-batches\nbatch_size = 32\nnum_batches = (1000 + batch_size - 1) // batch_size\n\nfor i in range(num_batches):\n    start = i * batch_size\n    stop = min((i + 1) * batch_size, 1000)\n    mini_batch = nested.slice_along_batch(dataset, start=start, stop=stop)\n</code></pre>"},{"location":"tutorials/batches/#data-augmentation","title":"Data Augmentation","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\nbatch = {\"images\": np.random.randn(32, 28, 28), \"labels\": np.random.randint(0, 10, 32)}\n\n# Shuffle for augmentation\naugmented = nested.shuffle_along_batch(batch)\n\n# Select random subset\nindices = np.random.choice(32, size=16, replace=False)\nsubset = nested.index_select_along_batch(augmented, indices=indices)\n</code></pre>"},{"location":"tutorials/nested/","title":"Tutorial: Advanced Nested Operations","text":"<p>This tutorial covers advanced techniques for working with complex nested data structures in <code>batcharray</code>.</p>"},{"location":"tutorials/nested/#introduction","title":"Introduction","text":"<p>Real-world data is often organized in complex nested structures:</p> <ul> <li>Multiple related arrays in dictionaries</li> <li>Lists or tuples of arrays</li> <li>Deeply nested combinations of both</li> </ul> <p>The <code>batcharray.nested</code> module provides powerful tools to work with these structures efficiently.</p>"},{"location":"tutorials/nested/#understanding-nested-structures","title":"Understanding Nested Structures","text":""},{"location":"tutorials/nested/#what-are-nested-structures","title":"What Are Nested Structures?","text":"<p>Nested structures are hierarchical data organizations containing NumPy arrays:</p> <pre><code>import numpy as np\n\n# Simple dictionary\nsimple_nested = {\"features\": np.array([[1, 2], [3, 4]]), \"labels\": np.array([0, 1])}\n\n# List of arrays\nlist_nested = [np.array([[1, 2], [3, 4]]), np.array([[5, 6], [7, 8]])]\n\n# Complex nesting\ncomplex_nested = {\n    \"train\": {\"inputs\": np.array([[1, 2], [3, 4]]), \"targets\": np.array([0, 1])},\n    \"metadata\": {\"weights\": np.array([1.0, 0.8]), \"ids\": np.array([\"a\", \"b\"])},\n}\n</code></pre>"},{"location":"tutorials/nested/#why-use-nested-operations","title":"Why Use Nested Operations?","text":"<p>Nested operations ensure consistency across related arrays:</p> <pre><code>import numpy as np\nfrom batcharray import nested\n\n# Without nested operations - INCONSISTENT!\ndata = {\"features\": np.array([[1, 2], [3, 4], [5, 6]]), \"labels\": np.array([0, 1, 0])}\n\n# Manually slicing - easy to make mistakes\nsliced_features = data[\"features\"][:2]\nsliced_labels = data[\"labels\"][:3]  # Oops! Different size!\n\n# With nested operations - CONSISTENT!\nsliced_data = nested.slice_along_batch(data, stop=2)\n# Both features and labels are sliced to 2 items\n</code></pre>"},{"location":"tutorials/nested/#mathematical-operations-on-nested-structures","title":"Mathematical Operations on Nested Structures","text":""},{"location":"tutorials/nested/#element-wise-operations","title":"Element-wise Operations","text":"<p>Apply mathematical functions to all arrays in a structure:</p> <pre><code>import numpy as np\nfrom batcharray import nested\n\ndata = {\n    \"values\": np.array([[-2.0, 3.0], [1.0, -4.0]]),\n    \"scores\": np.array([[0.5, -0.5], [0.2, -0.8]]),\n}\n\n# Absolute values\nabs_data = nested.abs(data)\n# {\n#     'values': array([[2., 3.],\n#                      [1., 4.]]),\n#     'scores': array([[0.5, 0.5],\n#                      [0.2, 0.8]])\n# }\n\n# Exponential\nexp_data = nested.exp(data)\n\n# Logarithm (of absolute values to avoid errors)\nlog_data = nested.log(nested.abs(data))\n\n# Clipping\nclipped_data = nested.clip(data, a_min=-1.0, a_max=1.0)\n# {\n#     'values': array([[-1.,  1.],\n#                      [ 1., -1.]]),\n#     'scores': array([[ 0.5, -0.5],\n#                      [ 0.2, -0.8]])\n# }\n</code></pre>"},{"location":"tutorials/nested/#exponential-and-logarithmic-functions","title":"Exponential and Logarithmic Functions","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\n# Use positive values to avoid log(0) errors\ndata = {\n    \"x\": np.array([[0.1, 1.0], [2.0, 3.0]]),\n    \"y\": np.array([[0.5, 1.5], [2.5, 3.5]]),\n}\n\n# Standard exponential\nexp_result = nested.exp(data)\n\n# Base-2 exponential\nexp2_result = nested.exp2(data)\n\n# exp(x) - 1 (more accurate for small values)\nexpm1_result = nested.expm1(data)\n\n# Natural logarithm\nlog_result = nested.log(data)\n\n# Base-2 logarithm\nlog2_result = nested.log2(data)\n\n# Base-10 logarithm\nlog10_result = nested.log10(data)\n\n# log(1 + x) (more accurate for small values)\nlog1p_result = nested.log1p(data)\n</code></pre>"},{"location":"tutorials/nested/#trigonometric-functions","title":"Trigonometric Functions","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\n# Angles in radians\nangles = {\n    \"theta\": np.array([[0.0, np.pi / 4], [np.pi / 2, np.pi]]),\n    \"phi\": np.array([[0.0, np.pi / 6], [np.pi / 3, np.pi / 2]]),\n}\n\n# Sine\nsin_result = nested.sin(angles)\n# [[0.        0.70710678]\n#  [1.        0.        ]]\n\n# Cosine\ncos_result = nested.cos(angles)\n\n# Tangent\ntan_result = nested.tan(angles)\n\n# Hyperbolic functions\nsinh_result = nested.sinh(angles)\ncosh_result = nested.cosh(angles)\ntanh_result = nested.tanh(angles)\n\n# Inverse trigonometric functions (arcsin, arccos require values in [-1, 1])\nvalues_trig = {\n    \"x\": np.array([[0.0, 0.5], [0.7, 1.0]]),\n    \"y\": np.array([[0.0, 0.3], [0.6, 0.9]]),\n}\n\narcsin_result = nested.arcsin(values_trig)\narccos_result = nested.arccos(values_trig)\narctan_result = nested.arctan(values_trig)\n\n# Inverse hyperbolic functions\n# arcsinh works for all values\narcsinh_result = nested.arcsinh(values_trig)\n\n# arccosh requires values &gt;= 1\nvalues_cosh = {\n    \"x\": np.array([[1.0, 1.5], [2.0, 3.0]]),\n    \"y\": np.array([[1.0, 1.2], [1.8, 2.5]]),\n}\narccosh_result = nested.arccosh(values_cosh)\n\n# arctanh requires -1 &lt; values &lt; 1 (strictly between, not including -1 and 1)\nvalues_tanh = {\n    \"x\": np.array([[0.0, 0.5], [0.7, 0.9]]),\n    \"y\": np.array([[0.0, 0.3], [0.6, 0.8]]),\n}\narctanh_result = nested.arctanh(values_tanh)\n</code></pre>"},{"location":"tutorials/nested/#advanced-indexing-and-selection","title":"Advanced Indexing and Selection","text":""},{"location":"tutorials/nested/#masked-selection","title":"Masked Selection","text":"<p>Select elements based on boolean masks:</p> <pre><code>import numpy as np\nfrom batcharray import nested\n\ndata = {\n    \"features\": np.array([[1, 2], [3, 4], [5, 6], [7, 8]]),\n    \"scores\": np.array([0.1, 0.9, 0.3, 0.8]),\n    \"ids\": np.array([10, 20, 30, 40]),\n}\n\n# Select high-scoring items (scores &gt; 0.5)\nmask = data[\"scores\"] &gt; 0.5\nfiltered = nested.masked_select_along_batch(data, mask=mask)\n# {\n#     'features': array([[3, 4],\n#                        [7, 8]]),\n#     'scores': array([0.9, 0.8]),\n#     'ids': array([20, 40])\n# }\n</code></pre>"},{"location":"tutorials/nested/#advanced-indexing","title":"Advanced Indexing","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\ndata = {\"A\": np.array([[1, 2], [3, 4], [5, 6]]), \"B\": np.array([10, 20, 30])}\n\n# Select in custom order\nindices = np.array([2, 0, 2, 1])  # Can repeat indices\nreordered = nested.index_select_along_batch(data, indices=indices)\n# {\n#     'A': array([[5, 6],\n#                 [1, 2],\n#                 [5, 6],\n#                 [3, 4]]),\n#     'B': array([30, 10, 30, 20])\n# }\n</code></pre>"},{"location":"tutorials/nested/#take-along-axis","title":"Take Along Axis","text":"<p>Select elements using indices array (useful after sorting):</p> <pre><code>import numpy as np\nfrom batcharray import nested\n\ndata = {\"values\": np.array([[5, 2], [1, 4], [3, 6]]), \"labels\": np.array([0, 1, 0])}\n\n# Get sort indices\nsort_indices = nested.argsort_along_batch(data[\"values\"])\n# [[1 0]   # For column 0: indices that would sort [5,1,3] -&gt; [1,3,5]\n#  [2 1]   # For column 1: indices that would sort [2,4,6] -&gt; [2,4,6]\n#  [0 2]]\n\n# Use those indices to sort all arrays\nsorted_data = nested.take_along_batch(data, indices=sort_indices[:, 0:1])\n# Takes first column of indices for all arrays\n</code></pre>"},{"location":"tutorials/nested/#reductions-and-aggregations","title":"Reductions and Aggregations","text":""},{"location":"tutorials/nested/#statistical-reductions","title":"Statistical Reductions","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\ndata = {\n    \"train_scores\": np.array([[0.8, 0.9], [0.7, 0.85], [0.75, 0.88]]),\n    \"val_scores\": np.array([[0.7, 0.8], [0.65, 0.75], [0.68, 0.78]]),\n}\n\n# Mean across batches\nmean_scores = nested.mean_along_batch(data)\n# {\n#     'train_scores': array([0.75      , 0.87666667]),\n#     'val_scores': array([0.67666667, 0.77666667])\n# }\n\n# Maximum values\nmax_scores = nested.amax_along_batch(data)\n\n# Minimum values\nmin_scores = nested.amin_along_batch(data)\n\n# Median values\nmedian_scores = nested.median_along_batch(data)\n\n# Sum across batches\nsum_scores = nested.sum_along_batch(data)\n\n# Product across batches\nprod_scores = nested.prod_along_batch(data)\n</code></pre>"},{"location":"tutorials/nested/#finding-extremes","title":"Finding Extremes","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\ndata = {\n    \"scores\": np.array([[0.2, 0.8], [0.5, 0.6], [0.9, 0.3]]),\n    \"metrics\": np.array([[1.0, 2.0], [1.5, 1.8], [0.8, 2.2]]),\n}\n\n# Indices of maximum values\nargmax_data = nested.argmax_along_batch(data)\n# {\n#     'scores': array([2, 0]),    # Max scores: col 0 at idx 2, col 1 at idx 0\n#     'metrics': array([1, 2])    # Max metrics: col 0 at idx 1, col 1 at idx 2\n# }\n\n# Indices of minimum values\nargmin_data = nested.argmin_along_batch(data)\n</code></pre>"},{"location":"tutorials/nested/#sequence-wise-reductions","title":"Sequence-wise Reductions","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\nsequences = {\n    \"inputs\": np.array([[[1, 2], [3, 4], [5, 6]], [[7, 8], [9, 10], [11, 12]]]),\n    \"outputs\": np.array(\n        [[[0.1, 0.2], [0.3, 0.4], [0.5, 0.6]], [[0.7, 0.8], [0.9, 1.0], [1.1, 1.2]]]\n    ),\n}\n\n# Mean over sequence dimension\nmean_over_time = nested.mean_along_seq(sequences)\n# {\n#     'inputs': array([[ 3.,  4.],    # Mean of [[1,2], [3,4], [5,6]]\n#                      [ 9., 10.]]),  # Mean of [[7,8], [9,10], [11,12]]\n#     'outputs': array([[0.3, 0.4],\n#                       [0.9, 1. ]])\n# }\n\n# Sum over sequences\nsum_over_time = nested.sum_along_seq(sequences)\n\n# Max over sequences\nmax_over_time = nested.amax_along_seq(sequences)\n</code></pre>"},{"location":"tutorials/nested/#cumulative-operations","title":"Cumulative Operations","text":""},{"location":"tutorials/nested/#cumulative-sum-and-product","title":"Cumulative Sum and Product","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\ndata = {\n    \"sales\": np.array([[10, 20], [15, 25], [12, 18]]),\n    \"costs\": np.array([[5, 10], [8, 12], [6, 9]]),\n}\n\n# Cumulative sum along batches (running totals)\ncumsum_batch = nested.cumsum_along_batch(data)\n# {\n#     'sales': array([[10, 20],\n#                     [25, 45],   # 10+15, 20+25\n#                     [37, 63]]), # 10+15+12, 20+25+18\n#     'costs': array([[ 5, 10],\n#                     [13, 22],   # 5+8, 10+12\n#                     [19, 31]])  # 5+8+6, 10+12+9\n# }\n\n# Cumulative product\ncumprod_batch = nested.cumprod_along_batch(data)\n</code></pre>"},{"location":"tutorials/nested/#sequence-cumulative-operations","title":"Sequence Cumulative Operations","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\nsequences = {\"values\": np.array([[[1, 2], [3, 4], [5, 6]], [[2, 3], [4, 5], [6, 7]]])}\n\n# Cumulative sum over time\ncumsum_seq = nested.cumsum_along_seq(sequences)\n# {\n#     'values': array([[[ 1,  2],\n#                       [ 4,  6],   # 1+3, 2+4\n#                       [ 9, 12]],  # 1+3+5, 2+4+6\n#\n#                      [[ 2,  3],\n#                       [ 6,  8],   # 2+4, 3+5\n#                       [12, 15]]]) # 2+4+6, 3+5+7\n# }\n\n# Cumulative product over time\ncumprod_seq = nested.cumprod_along_seq(sequences)\n</code></pre>"},{"location":"tutorials/nested/#combining-and-joining","title":"Combining and Joining","text":""},{"location":"tutorials/nested/#concatenation","title":"Concatenation","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\nbatch1 = {\n    \"features\": np.array([[1, 2], [3, 4]]),\n    \"labels\": np.array([0, 1]),\n    \"weights\": np.array([1.0, 0.8]),\n}\n\nbatch2 = {\n    \"features\": np.array([[5, 6]]),\n    \"labels\": np.array([0]),\n    \"weights\": np.array([1.2]),\n}\n\nbatch3 = {\n    \"features\": np.array([[7, 8], [9, 10]]),\n    \"labels\": np.array([1, 0]),\n    \"weights\": np.array([0.9, 1.1]),\n}\n\n# Concatenate multiple batches\ncombined = nested.concatenate_along_batch([batch1, batch2, batch3])\n# {\n#     'features': array([[1, 2],\n#                        [3, 4],\n#                        [5, 6],\n#                        [7, 8],\n#                        [9, 10]]),\n#     'labels': array([0, 1, 0, 1, 0]),\n#     'weights': array([1. , 0.8, 1.2, 0.9, 1.1])\n# }\n</code></pre>"},{"location":"tutorials/nested/#sequence-concatenation","title":"Sequence Concatenation","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\nseq1 = {\"tokens\": np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])}\n\nseq2 = {\"tokens\": np.array([[[9, 10]], [[11, 12]]])}\n\n# Concatenate along sequence dimension\ncombined_seq = nested.concatenate_along_seq([seq1, seq2])\n# (2, 3, 2)\n</code></pre>"},{"location":"tutorials/nested/#tiling","title":"Tiling","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\nsequences = {\n    \"pattern\": np.array([[[1, 2]], [[3, 4]]]),\n    \"mask\": np.array([[True], [False]]),\n}\n\n# Repeat sequence 4 times\ntiled = nested.tile_along_seq(sequences, reps=4)\n</code></pre>"},{"location":"tutorials/nested/#shuffling-and-permutations","title":"Shuffling and Permutations","text":""},{"location":"tutorials/nested/#random-shuffling","title":"Random Shuffling","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\n# Set seed for reproducibility\nnp.random.seed(42)\n\ndata = {\n    \"features\": np.array([[1, 2], [3, 4], [5, 6], [7, 8]]),\n    \"labels\": np.array([0, 1, 0, 1]),\n    \"ids\": np.array([\"a\", \"b\", \"c\", \"d\"]),\n}\n\n# Shuffle all arrays with same permutation\nshuffled = nested.shuffle_along_batch(data)\n# All arrays shuffled identically to maintain alignment\n</code></pre>"},{"location":"tutorials/nested/#custom-permutations","title":"Custom Permutations","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\ndata = {\"X\": np.array([[1, 2], [3, 4], [5, 6]]), \"y\": np.array([0, 1, 0])}\n\n# Apply specific permutation\nperm = np.array([2, 0, 1])  # Reverse order\npermuted = nested.permute_along_batch(data, permutation=perm)\n# {\n#     'X': array([[5, 6],\n#                 [1, 2],\n#                 [3, 4]]),\n#     'y': array([0, 0, 1])\n# }\n</code></pre>"},{"location":"tutorials/nested/#sequence-shuffling","title":"Sequence Shuffling","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\nsequences = {\"frames\": np.array([[[1], [2], [3], [4]], [[5], [6], [7], [8]]])}\n\n# Shuffle time steps (useful for certain augmentations)\nshuffled_seq = nested.shuffle_along_seq(sequences)\n# Time steps are shuffled within each sequence\n</code></pre>"},{"location":"tutorials/nested/#sorting","title":"Sorting","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\ndata = {\n    \"scores\": np.array([[5, 2], [1, 4], [3, 6]]),\n    \"names\": np.array([[\"e\", \"b\"], [\"a\", \"d\"], [\"c\", \"f\"]]),\n}\n\n# Sort along batch dimension\nsorted_data = nested.sort_along_batch(data)\n# {\n#     'scores': array([[1, 2],\n#                      [3, 4],\n#                      [5, 6]]),\n#     'names': array([['a', 'b'],\n#                     ['c', 'd'],\n#                     ['e', 'f']], dtype='&lt;U1')\n# }\n\n# Get sort indices\nsort_indices = nested.argsort_along_batch(data[\"scores\"])\n</code></pre>"},{"location":"tutorials/nested/#converting-to-native-python","title":"Converting to Native Python","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\ndata = {\n    \"features\": np.array([[1, 2], [3, 4]]),\n    \"labels\": np.array([0, 1]),\n    \"nested\": {\"values\": np.array([10.0, 20.0])},\n}\n\n# Convert to native Python lists\npython_data = nested.to_list(data)\n# {\n#     'features': [[1, 2], [3, 4]],\n#     'labels': [0, 1],\n#     'nested': {\n#         'values': [10.0, 20.0]\n#     }\n# }\n</code></pre>"},{"location":"tutorials/nested/#complex-examples","title":"Complex Examples","text":""},{"location":"tutorials/nested/#time-series-processing","title":"Time-Series Processing","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\n# Multi-variate time series\nsequences = {\n    \"sensor_1\": np.random.randn(10, 100, 5),  # 10 sequences, 100 steps\n    \"sensor_2\": np.random.randn(10, 100, 3),\n    \"labels\": np.random.randint(0, 2, (10, 100)),\n}\n\n# Slice to analysis window\nwindow = nested.slice_along_seq(sequences, start=20, stop=80)\n\n# Compute statistics over time\nsummary = nested.mean_along_seq(window)\n# (10, 5)\n\n# Normalize\nnormalized = {\n    \"sensor_1\": (window[\"sensor_1\"] - summary[\"sensor_1\"][:, None, :])\n    / (window[\"sensor_1\"].std(axis=1, keepdims=True) + 1e-8),\n    \"sensor_2\": (window[\"sensor_2\"] - summary[\"sensor_2\"][:, None, :])\n    / (window[\"sensor_2\"].std(axis=1, keepdims=True) + 1e-8),\n    \"labels\": window[\"labels\"],\n}\n</code></pre>"},{"location":"tutorials/nested/#next-steps","title":"Next Steps","text":"<ul> <li>Review the nested API reference for all available functions</li> <li>Learn about computation models for low-level operations</li> <li>Check the FAQ for common questions and solutions</li> <li>See batch operations tutorial for simpler cases</li> </ul>"},{"location":"tutorials/sequences/","title":"Tutorial: Working with Sequences","text":"<p>This tutorial covers how to work with sequences (time-series data) using <code>batcharray</code>.</p>"},{"location":"tutorials/sequences/#introduction","title":"Introduction","text":"<p>Sequences are ordered collections of data points, commonly found in:</p> <ul> <li>Time-series data (sensor readings)</li> <li>Natural language processing (sentences, documents)</li> <li>Video processing (frames over time)</li> <li>Audio processing (audio samples)</li> </ul> <p>In <code>batcharray</code>, sequences have two important dimensions:</p> <ul> <li>Batch dimension (axis 0): Different sequences</li> <li>Sequence dimension (axis 1): Time steps within each sequence</li> </ul>"},{"location":"tutorials/sequences/#basic-sequence-operations","title":"Basic Sequence Operations","text":""},{"location":"tutorials/sequences/#creating-sequence-data","title":"Creating Sequence Data","text":"<pre><code>import numpy as np\nfrom batcharray import array\n\n# Create a batch of 3 sequences, each with 4 time steps and 2 features\nsequences = np.array(\n    [\n        # Sequence 1\n        [[1.0, 2.0], [3.0, 4.0], [5.0, 6.0], [7.0, 8.0]],  # t=0  # t=1  # t=2  # t=3\n        # Sequence 2\n        [[9.0, 10.0], [11.0, 12.0], [13.0, 14.0], [15.0, 16.0]],\n        # Sequence 3\n        [[17.0, 18.0], [19.0, 20.0], [21.0, 22.0], [23.0, 24.0]],\n    ]\n)\n</code></pre>"},{"location":"tutorials/sequences/#slicing-sequences","title":"Slicing Sequences","text":"<p>You can slice along the sequence dimension to extract time windows:</p> <p>```python continuation</p>"},{"location":"tutorials/sequences/#get-first-2-time-steps-for-all-sequences","title":"Get first 2 time steps for all sequences","text":"<p>first_steps = array.slice_along_seq(sequences, stop=2)</p>"},{"location":"tutorials/sequences/#shape-3-2-2","title":"Shape: (3, 2, 2)","text":""},{"location":"tutorials/sequences/#1-2","title":"[[[ 1.  2.]","text":""},{"location":"tutorials/sequences/#3-4","title":"[ 3.  4.]]","text":""},{"location":"tutorials/sequences/#_1","title":"Working with Sequences","text":""},{"location":"tutorials/sequences/#9-10","title":"[[ 9. 10.]","text":""},{"location":"tutorials/sequences/#11-12","title":"[11. 12.]]","text":""},{"location":"tutorials/sequences/#_2","title":"Working with Sequences","text":""},{"location":"tutorials/sequences/#17-18","title":"[[17. 18.]","text":""},{"location":"tutorials/sequences/#19-20","title":"[19. 20.]]]","text":""},{"location":"tutorials/sequences/#get-time-steps-1-3-middle-portion","title":"Get time steps 1-3 (middle portion)","text":"<p>middle_steps = array.slice_along_seq(sequences, start=1, stop=3)</p>"},{"location":"tutorials/sequences/#shape-3-2-2_1","title":"Shape: (3, 2, 2)","text":""},{"location":"tutorials/sequences/#get-last-time-step","title":"Get last time step","text":"<p>last_step = array.slice_along_seq(sequences, start=3)</p>"},{"location":"tutorials/sequences/#shape-3-1-2","title":"Shape: (3, 1, 2)","text":"<pre><code>### Selecting Specific Time Steps\n\n```python continuation\n# Select specific time steps\ntime_indices = np.array([0, 2])  # Get t=0 and t=2\nselected = array.index_select_along_seq(sequences, indices=time_indices)\n# Shape: (3, 2, 2)\n</code></pre>"},{"location":"tutorials/sequences/#splitting-sequences","title":"Splitting Sequences","text":"<p>```python continuation</p>"},{"location":"tutorials/sequences/#split-sequence-into-chunks","title":"Split sequence into chunks","text":"<p>chunks = array.chunk_along_seq(sequences, chunks=2)</p>"},{"location":"tutorials/sequences/#array-1-2-3-4","title":"[array([[[ 1.,  2.], [ 3.,  4.]],","text":""},{"location":"tutorials/sequences/#9-10-11-12","title":"[[ 9., 10.], [11., 12.]],","text":""},{"location":"tutorials/sequences/#17-18-19-20","title":"[[17., 18.], [19., 20.]]]),","text":""},{"location":"tutorials/sequences/#array-5-6-7-8","title":"array([[[ 5.,  6.], [ 7.,  8.]],","text":""},{"location":"tutorials/sequences/#13-14-15-16","title":"[[13., 14.], [15., 16.]],","text":""},{"location":"tutorials/sequences/#21-22-23-24","title":"[[21., 22.], [23., 24.]]])]","text":""},{"location":"tutorials/sequences/#split-at-specific-points","title":"Split at specific points","text":"<p>splits = array.split_along_seq(sequences, split_size_or_sections=[1, 2, 1])</p>"},{"location":"tutorials/sequences/#array-1-2-9-10-17-18","title":"[array([[[ 1.,  2.]], [[ 9., 10.]], [[17., 18.]]]),","text":""},{"location":"tutorials/sequences/#array-3-4-5-6","title":"array([[[ 3.,  4.], [ 5.,  6.]],","text":""},{"location":"tutorials/sequences/#11-12-13-14","title":"[[11., 12.],  [13., 14.]],","text":""},{"location":"tutorials/sequences/#19-20-21-22","title":"[[19., 20.], [21., 22.]]]),","text":""},{"location":"tutorials/sequences/#array-7-8-15-16-23-24","title":"array([[[ 7.,  8.]], [[15., 16.]], [[23., 24.]]])]","text":"<pre><code>## Sequence Statistics\n\n### Computing Statistics Over Time\n\n```python\nimport numpy as np\nfrom batcharray import array\n\nsequences = np.array(\n    [[[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]], [[7.0, 8.0], [9.0, 10.0], [11.0, 12.0]]]\n)\n# Shape: (2, 3, 2) - 2 sequences, 3 time steps, 2 features\n\n# Mean over time for each sequence\nmean_over_time = array.mean_along_seq(sequences)\n# [[ 3.  4.]    # Sequence 1: mean of all time steps\n#  [ 9. 10.]]   # Sequence 2: mean of all time steps\n\n# Maximum over time\nmax_over_time = array.amax_along_seq(sequences)\n# [[ 5.  6.]    # Sequence 1: max across time\n#  [11. 12.]]   # Sequence 2: max across time\n\n# Sum over time\nsum_over_time = array.sum_along_seq(sequences)\n# [[ 9. 12.]    # Sequence 1: sum across time\n#  [27. 30.]]   # Sequence 2: sum across time\n</code></pre>"},{"location":"tutorials/sequences/#finding-extremes-in-sequences","title":"Finding Extremes in Sequences","text":"<pre><code>import numpy as np\nfrom batcharray import array\n\nsequences = np.array(\n    [[[0.1, 0.2], [0.5, 0.3], [0.2, 0.8]], [[0.3, 0.4], [0.1, 0.9], [0.7, 0.2]]]\n)\n\n# Find time step with maximum value for each feature\nmax_indices = array.argmax_along_seq(sequences)\n# [[1 2]    # Sequence 1: max at t=1 for feat 0, t=2 for feat 1\n#  [2 1]]   # Sequence 2: max at t=2 for feat 0, t=1 for feat 1\n\n# Find actual maximum values\nmax_values = array.amax_along_seq(sequences)\n# [[0.5 0.8]\n#  [0.7 0.9]]\n</code></pre>"},{"location":"tutorials/sequences/#cumulative-operations","title":"Cumulative Operations","text":"<p>Cumulative operations are particularly useful for sequences:</p> <pre><code>import numpy as np\nfrom batcharray import array\n\nsequences = np.array([[[1, 2], [3, 4], [5, 6]], [[7, 8], [9, 10], [11, 12]]])\n\n# Cumulative sum over time\ncumsum = array.cumsum_along_seq(sequences)\n# [[[ 1  2]\n#   [ 4  6]   # 1+3, 2+4\n#   [ 9 12]]  # 1+3+5, 2+4+6\n#\n#  [[ 7  8]\n#   [16 18]   # 7+9, 8+10\n#   [27 30]]] # 7+9+11, 8+10+12\n\n# Cumulative product over time\ncumprod = array.cumprod_along_seq(sequences)\n# [[[ 1   2]\n#   [ 3   8]   # 1*3, 2*4\n#   [15  48]]  # 1*3*5, 2*4*6\n#\n#  [[ 7   8]\n#   [63  80]   # 7*9, 8*10\n#   [693 880]]] # 7*9*11, 8*10*12\n</code></pre>"},{"location":"tutorials/sequences/#working-with-nested-sequences","title":"Working with Nested Sequences","text":"<p>When you have multiple related sequences, use the <code>nested</code> module:</p> <pre><code>import numpy as np\nfrom batcharray import nested\n\n# Batch of sequences with inputs and targets\nsequences = {\n    \"inputs\": np.array([[[1, 2], [3, 4], [5, 6]], [[7, 8], [9, 10], [11, 12]]]),\n    \"targets\": np.array([[[0], [1], [0]], [[1], [1], [0]]]),\n    \"masks\": np.array([[True, True, False], [True, True, True]]),\n}\n\n# Slice all sequences to first 2 time steps\nsliced = nested.slice_along_seq(sequences, stop=2)\n# Shape inputs: (2, 2, 2)\n# Shape targets: (2, 2, 1)\n# Shape masks: (2, 2)\n</code></pre>"},{"location":"tutorials/sequences/#sorting-sequences","title":"Sorting Sequences","text":""},{"location":"tutorials/sequences/#sorting-by-time","title":"Sorting by Time","text":"<pre><code>import numpy as np\nfrom batcharray import array\n\nsequences = np.array([[[5, 2], [1, 4], [3, 6]], [[8, 7], [9, 5], [6, 8]]])\n\n# Sort along sequence dimension\nsorted_seq = array.sort_along_seq(sequences)\n# [[[1 2]\n#   [3 4]\n#   [5 6]]\n#\n#  [[6 5]\n#   [8 7]\n#   [9 8]]]\n</code></pre>"},{"location":"tutorials/sequences/#tiling-and-repeating-sequences","title":"Tiling and Repeating Sequences","text":"<pre><code>import numpy as np\nfrom batcharray import array\n\nsequences = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\n# Shape: (2, 2, 2)\n\n# Repeat sequence 3 times\ntiled = array.tile_along_seq(sequences, reps=3)\n# Shape: (2, 6, 2)\n# The first sequence is:\n# [[1 2]\n#  [3 4]\n#  [1 2]\n#  [3 4]\n#  [1 2]\n#  [3 4]]\n</code></pre>"},{"location":"tutorials/sequences/#combining-sequence-operations","title":"Combining Sequence Operations","text":"<p>You can combine batch and sequence operations:</p> <pre><code>import numpy as np\nfrom batcharray import array\n\n# Create sequences: 10 sequences, 20 time steps, 5 features\nsequences = np.random.randn(10, 20, 5)\n\n# Select specific sequences (batch operation)\nselected_sequences = array.index_select_along_batch(\n    sequences, indices=np.array([0, 2, 4, 6, 8])\n)\n# Shape: (5, 20, 5)\n\n# Then slice time window (sequence operation)\ntime_window = array.slice_along_seq(selected_sequences, start=5, stop=15)\n# Shape: (5, 10, 5)\n\n# Compute statistics over time\ntime_mean = array.mean_along_seq(time_window)\n# Shape: (5, 5) - mean for each sequence\n</code></pre>"},{"location":"tutorials/sequences/#variable-length-sequences","title":"Variable-Length Sequences","text":"<p>Real-world sequences often have different lengths. Use masked arrays:</p> <pre><code>import numpy as np\nimport numpy.ma as ma\nfrom batcharray import array\n\n# Create sequences with different lengths (padded and masked)\n# Actual lengths: [4, 3, 2]\nsequences = ma.array(\n    [\n        [[1, 2], [3, 4], [5, 6], [7, 8]],  # Full sequence\n        [[9, 10], [11, 12], [13, 14], [0, 0]],  # Length 3 (last padded)\n        [[15, 16], [17, 18], [0, 0], [0, 0]],  # Length 2 (last 2 padded)\n    ],\n    mask=[\n        [[0, 0], [0, 0], [0, 0], [0, 0]],\n        [[0, 0], [0, 0], [0, 0], [1, 1]],\n        [[0, 0], [0, 0], [1, 1], [1, 1]],\n    ],\n)\n\n# Compute mean (automatically handles variable lengths)\nmean_over_time = array.mean_along_seq(sequences)\n# [[ 4.  5.]\n#  [11. 12.]\n#  [16. 17.]]\n</code></pre>"},{"location":"tutorials/sequences/#common-use-cases","title":"Common Use Cases","text":""},{"location":"tutorials/sequences/#sliding-window-analysis","title":"Sliding Window Analysis","text":"<pre><code>import numpy as np\nfrom batcharray import array\n\n# Time series data\ntime_series = np.random.randn(1, 100, 3)  # 1 long sequence\n\n# Create sliding windows of size 10\nwindow_size = 10\nstride = 5\nwindows = []\n\nfor i in range(0, 100 - window_size + 1, stride):\n    window = array.slice_along_seq(time_series, start=i, stop=i + window_size)\n    windows.append(window)\n\n# Stack windows into batch\nwindowed_batch = np.concatenate(windows, axis=0)\n</code></pre>"},{"location":"tutorials/sequences/#sequence-truncation","title":"Sequence Truncation","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\n# Truncate all sequences to same length\nsequences = {\n    \"text\": np.random.randint(0, 1000, (32, 50)),  # 32 sequences, max 50 tokens\n    \"labels\": np.random.randint(0, 2, (32, 50)),\n}\n\n# Truncate to 30 tokens\nmax_length = 30\ntruncated = nested.slice_along_seq(sequences, stop=max_length)\n</code></pre>"},{"location":"tutorials/sequences/#time-series-forecasting-preparation","title":"Time-Series Forecasting Preparation","text":"<pre><code>import numpy as np\nfrom batcharray import array\n\n# Historical data: (batch, time, features)\nhistory = np.random.randn(100, 24, 5)  # 24 hours of history\n\n# Use first 18 hours for input, predict last 6 hours\ninput_window = array.slice_along_seq(history, stop=18)\ntarget_window = array.slice_along_seq(history, start=18)\n</code></pre>"},{"location":"tutorials/sequences/#sequence-aggregation","title":"Sequence Aggregation","text":"<pre><code>import numpy as np\nfrom batcharray import array\n\nsequences = np.array(\n    [[[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[10, 11, 12], [13, 14, 15], [16, 17, 18]]]\n)\n\n# Different aggregations over time\nmean_rep = array.mean_along_seq(sequences)  # Average over time\nmax_rep = array.amax_along_seq(sequences)  # Max pooling over time\nsum_rep = array.sum_along_seq(sequences)  # Sum over time\n</code></pre>"},{"location":"tutorials/sequences/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about batch operations for working with collections</li> <li>Explore nested structures for complex data</li> <li>See the array reference for all available functions</li> <li>Check out the FAQ for common questions</li> </ul>"},{"location":"uguide/array/","title":"Array Operations","text":"<p>The <code>batcharray.array</code> module provides functions to manipulate NumPy arrays representing batches of data and sequences.</p>"},{"location":"uguide/array/#overview","title":"Overview","text":"<p><code>batcharray</code> provides two main categories of array operations:</p> <ol> <li>Batch operations: Work on arrays with shape <code>(batch_size, ...)</code> where the first axis is the batch dimension</li> <li>Sequence operations: Work on arrays with shape <code>(batch_size, seq_len, ...)</code> where the first axis is batch and second is sequence</li> </ol>"},{"location":"uguide/array/#batch-operations","title":"Batch Operations","text":"<p>Batch operations work along the first axis (batch dimension) of arrays. All functions that operate on the batch dimension have the suffix <code>_along_batch</code>.</p>"},{"location":"uguide/array/#slicing-and-indexing","title":"Slicing and Indexing","text":"<pre><code>import numpy as np\nfrom batcharray import array\n\n# Create a batch of data\nbatch = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\n\n# Slice the batch\nsliced = array.slice_along_batch(batch, start=1, stop=3)\n# Result: [[4, 5, 6], [7, 8, 9]]\n\n# Select specific indices\nselected = array.index_select_along_batch(batch, indices=np.array([0, 2]))\n# Result: [[1, 2, 3], [7, 8, 9]]\n\n# Split into chunks\nchunks = array.chunk_along_batch(batch, chunks=2)\n# Result: [array([[1, 2, 3], [4, 5, 6]]), array([[7, 8, 9], [10, 11, 12]])]\n</code></pre>"},{"location":"uguide/array/#reductions","title":"Reductions","text":"<pre><code>import numpy as np\nfrom batcharray import array\n\nbatch = np.array([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]])\n\n# Compute statistics along batch\nmean_val = array.mean_along_batch(batch)  # [3.0, 4.0]\nmax_val = array.amax_along_batch(batch)  # [5.0, 6.0]\nsum_val = array.sum_along_batch(batch)  # [9.0, 12.0]\n</code></pre>"},{"location":"uguide/array/#sorting-and-permutation","title":"Sorting and Permutation","text":"<pre><code>import numpy as np\nfrom batcharray import array\n\nbatch = np.array([[5, 2], [1, 4], [3, 6]])\n\n# Sort along batch\nsorted_batch = array.sort_along_batch(batch)\n# Result: [[1, 2], [3, 4], [5, 6]]\n\n# Get sort indices\nindices = array.argsort_along_batch(batch)\n\n# Shuffle batch randomly\nshuffled = array.shuffle_along_batch(batch)\n</code></pre>"},{"location":"uguide/array/#sequence-operations","title":"Sequence Operations","text":"<p>Sequence operations work along the second axis (sequence dimension). All functions that operate on sequences have the suffix <code>_along_seq</code>.</p>"},{"location":"uguide/array/#sequence-manipulation","title":"Sequence Manipulation","text":"<pre><code>import numpy as np\nfrom batcharray import array\n\n# Batch of sequences: (batch_size=2, seq_len=4, features=3)\nsequences = np.array(\n    [\n        [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]],\n        [[13, 14, 15], [16, 17, 18], [19, 20, 21], [22, 23, 24]],\n    ]\n)\n\n# Slice sequences\nsliced = array.slice_along_seq(sequences, start=1, stop=3)\n# Shape: (2, 2, 3)\n\n# Tile sequences\ntiled = array.tile_along_seq(sequences, reps=2)\n# Repeats each sequence twice along the sequence dimension\n\n# Split sequences\nchunks = array.split_along_seq(sequences, split_size_or_sections=2)\n</code></pre>"},{"location":"uguide/array/#sequence-reductions","title":"Sequence Reductions","text":"<pre><code>import numpy as np\nfrom batcharray import array\n\nsequences = np.array(\n    [[[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]], [[7.0, 8.0], [9.0, 10.0], [11.0, 12.0]]]\n)\n\n# Compute mean for each batch across sequence\nmean_seq = array.mean_along_seq(sequences)\n# Shape: (2, 2) - one value per batch per feature\n\n# Cumulative sum along sequences\ncumsum = array.cumsum_along_seq(sequences)\n</code></pre>"},{"location":"uguide/array/#combining-operations","title":"Combining Operations","text":"<p>You can chain operations for complex transformations:</p> <pre><code>import numpy as np\nfrom batcharray import array\n\n# Create batch of sequences\ndata = np.random.randn(10, 20, 5)  # 10 batches, 20 timesteps, 5 features\n\n# Select specific batch items\ndata = array.index_select_along_batch(data, indices=np.array([0, 2, 4, 6, 8]))\n\n# Slice sequences to first 10 timesteps\ndata = array.slice_along_seq(data, stop=10)\n\n# Compute statistics\nmean = array.mean_along_seq(data)  # Average over time for each batch\n</code></pre>"},{"location":"uguide/array/#working-with-masked-arrays","title":"Working with Masked Arrays","text":"<p>All functions in <code>batcharray.array</code> support NumPy masked arrays, allowing you to handle missing or invalid data:</p> <pre><code>import numpy as np\nimport numpy.ma as ma\nfrom batcharray import array\n\n# Create masked array\ndata = ma.array(\n    [[1, 2, 3], [4, 5, 6], [7, 8, 9]], mask=[[0, 0, 1], [0, 1, 0], [1, 0, 0]]\n)\n\n# Operations work with masked values\nmean = array.mean_along_batch(data)\nsorted_data = array.sort_along_batch(data)\n</code></pre>"},{"location":"uguide/array/#complete-function-reference","title":"Complete Function Reference","text":"<p>The <code>array</code> module provides the following categories of functions:</p>"},{"location":"uguide/array/#comparison-and-sorting","title":"Comparison and Sorting","text":"<ul> <li><code>argsort_along_batch()</code> - Get indices that would sort along batch</li> <li><code>argsort_along_seq()</code> - Get indices that would sort along sequence</li> <li><code>sort_along_batch()</code> - Sort along batch dimension</li> <li><code>sort_along_seq()</code> - Sort along sequence dimension</li> </ul>"},{"location":"uguide/array/#indexing-and-selection","title":"Indexing and Selection","text":"<ul> <li><code>index_select_along_batch()</code> - Select using integer indices (batch)</li> <li><code>index_select_along_seq()</code> - Select using integer indices (sequence)</li> <li><code>masked_select_along_batch()</code> - Select using boolean mask (batch)</li> <li><code>masked_select_along_seq()</code> - Select using boolean mask (sequence)</li> <li><code>take_along_batch()</code> - Take elements using index array (batch)</li> <li><code>take_along_seq()</code> - Take elements using index array (sequence)</li> </ul>"},{"location":"uguide/array/#joining-and-combining","title":"Joining and Combining","text":"<ul> <li><code>concatenate_along_batch()</code> - Concatenate arrays along batch</li> <li><code>concatenate_along_seq()</code> - Concatenate arrays along sequence</li> <li><code>tile_along_seq()</code> - Repeat array along sequence dimension</li> </ul>"},{"location":"uguide/array/#mathematical-operations","title":"Mathematical Operations","text":"<ul> <li><code>cumprod_along_batch()</code> - Cumulative product along batch</li> <li><code>cumprod_along_seq()</code> - Cumulative product along sequence</li> <li><code>cumsum_along_batch()</code> - Cumulative sum along batch</li> <li><code>cumsum_along_seq()</code> - Cumulative sum along sequence</li> </ul>"},{"location":"uguide/array/#permutation-and-shuffling","title":"Permutation and Shuffling","text":"<ul> <li><code>permute_along_batch()</code> - Apply permutation to batch</li> <li><code>permute_along_seq()</code> - Apply permutation to sequence</li> <li><code>shuffle_along_batch()</code> - Random shuffle along batch</li> <li><code>shuffle_along_seq()</code> - Random shuffle along sequence</li> </ul>"},{"location":"uguide/array/#reduction-operations","title":"Reduction Operations","text":"<ul> <li><code>amax_along_batch()</code> / <code>max_along_batch()</code> - Maximum along batch</li> <li><code>amax_along_seq()</code> / <code>max_along_seq()</code> - Maximum along sequence</li> <li><code>amin_along_batch()</code> / <code>min_along_batch()</code> - Minimum along batch</li> <li><code>amin_along_seq()</code> / <code>min_along_seq()</code> - Minimum along sequence</li> <li><code>argmax_along_batch()</code> - Indices of maximum along batch</li> <li><code>argmax_along_seq()</code> - Indices of maximum along sequence</li> <li><code>argmin_along_batch()</code> - Indices of minimum along batch</li> <li><code>argmin_along_seq()</code> - Indices of minimum along sequence</li> <li><code>mean_along_batch()</code> - Mean along batch</li> <li><code>mean_along_seq()</code> - Mean along sequence</li> <li><code>median_along_batch()</code> - Median along batch</li> <li><code>median_along_seq()</code> - Median along sequence</li> <li><code>prod_along_batch()</code> - Product along batch</li> <li><code>prod_along_seq()</code> - Product along sequence</li> <li><code>sum_along_batch()</code> - Sum along batch</li> <li><code>sum_along_seq()</code> - Sum along sequence</li> </ul>"},{"location":"uguide/array/#slicing-operations","title":"Slicing Operations","text":"<ul> <li><code>chunk_along_batch()</code> - Split into equal chunks (batch)</li> <li><code>chunk_along_seq()</code> - Split into equal chunks (sequence)</li> <li><code>select_along_batch()</code> - Select single index (batch)</li> <li><code>select_along_seq()</code> - Select single index (sequence)</li> <li><code>slice_along_batch()</code> - Slice range of indices (batch)</li> <li><code>slice_along_seq()</code> - Slice range of indices (sequence)</li> <li><code>split_along_batch()</code> - Split into specified sections (batch)</li> <li><code>split_along_seq()</code> - Split into specified sections (sequence)</li> </ul> <p>For detailed API documentation of each function, see the array API reference.</p>"},{"location":"uguide/computation/","title":"Computation Models","text":"<p>The <code>batcharray.computation</code> module provides a flexible computation abstraction that allows operations to work with different array types (regular arrays, masked arrays, etc.) through a common interface.</p>"},{"location":"uguide/computation/#overview","title":"Overview","text":"<p>Computation models abstract away the details of different array types, allowing you to write code that works with:</p> <ul> <li>Standard NumPy arrays</li> <li>NumPy masked arrays</li> <li>Future array types</li> </ul> <p>The computation model automatically selects the appropriate implementation based on the input array type.</p>"},{"location":"uguide/computation/#basic-usage","title":"Basic Usage","text":""},{"location":"uguide/computation/#automatic-model-selection","title":"Automatic Model Selection","text":"<p>The easiest way to use computation models is through the interface functions with <code>AutoComputationModel</code>:</p> <pre><code>import numpy as np\nfrom batcharray import computation\n\n# Works with regular arrays\narr = np.array([[1, 2, 3], [4, 5, 6]])\nmax_val = computation.max(arr, axis=0)  # [4, 5, 6]\n\n# Automatically works with masked arrays too\nimport numpy.ma as ma\n\nmasked_arr = ma.array([[1, 2, 3], [4, 5, 6]], mask=[[0, 1, 0], [1, 0, 0]])\nmax_val = computation.max(masked_arr, axis=0)  # [4, --, 6]\n</code></pre>"},{"location":"uguide/computation/#available-operations","title":"Available Operations","text":"<p>The computation module provides several common operations:</p> <pre><code>import numpy as np\nfrom batcharray import computation\n\ndata = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n# Statistical operations\nmax_vals = computation.max(data, axis=0)  # [7, 8, 9]\nmin_vals = computation.min(data, axis=0)  # [1, 2, 3]\nmean_vals = computation.mean(data, axis=0)  # [4., 5., 6.]\nmedian_vals = computation.median(data, axis=0)  # [4., 5., 6.]\n\n# Indexing operations\nmax_indices = computation.argmax(data, axis=0)  # [2, 2, 2]\nmin_indices = computation.argmin(data, axis=0)  # [0, 0, 0]\n\n# Sorting\nsorted_data = computation.sort(data, axis=0)\nsort_indices = computation.argsort(data, axis=0)\n\n# Concatenation\nother = np.array([[10, 11, 12]])\ncombined = computation.concatenate([data, other], axis=0)\n</code></pre>"},{"location":"uguide/computation/#computation-models_1","title":"Computation Models","text":""},{"location":"uguide/computation/#arraycomputationmodel","title":"ArrayComputationModel","text":"<p>Handles standard NumPy arrays:</p> <pre><code>import numpy as np\nfrom batcharray.computation import ArrayComputationModel\n\nmodel = ArrayComputationModel()\n\narr = np.array([[1, 2, 3], [4, 5, 6]])\n\n# Use model methods\nmax_val = model.max(arr, axis=0)\nmean_val = model.mean(arr, axis=1)\nsorted_arr = model.sort(arr, axis=0)\n</code></pre>"},{"location":"uguide/computation/#maskedarraycomputationmodel","title":"MaskedArrayComputationModel","text":"<p>Handles NumPy masked arrays with special consideration for masked values:</p> <pre><code>import numpy as np\nimport numpy.ma as ma\nfrom batcharray.computation import MaskedArrayComputationModel\n\nmodel = MaskedArrayComputationModel()\n\n# Create masked array\nmasked_arr = ma.array(\n    [[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n    mask=[[False, True, False], [False, False, True], [True, False, False]],\n)\n\n# Operations handle masked values appropriately\nmax_val = model.max(masked_arr, axis=0)  # Ignores masked values\nmean_val = model.mean(masked_arr, axis=0)  # Computes mean of non-masked values\n</code></pre>"},{"location":"uguide/computation/#autocomputationmodel","title":"AutoComputationModel","text":"<p>Automatically selects the appropriate model based on input type:</p> <pre><code>import numpy as np\nimport numpy.ma as ma\nfrom batcharray.computation import AutoComputationModel\n\nauto_model = AutoComputationModel()\n\n# Works with regular arrays\nregular_arr = np.array([[1, 2, 3], [4, 5, 6]])\nresult1 = auto_model.max(regular_arr, axis=0)\n\n# Automatically switches to masked array handling\nmasked_arr = ma.array([[1, 2, 3], [4, 5, 6]], mask=[[0, 1, 0], [1, 0, 0]])\nresult2 = auto_model.max(masked_arr, axis=0)\n</code></pre>"},{"location":"uguide/computation/#custom-computation-models","title":"Custom Computation Models","text":"<p>You can create custom computation models by extending <code>BaseComputationModel</code>:</p> <pre><code>import numpy as np\nfrom batcharray.computation import BaseComputationModel, register_computation_models\n\n\nclass CustomArrayComputationModel(BaseComputationModel):\n    \"\"\"Custom computation model for special array types.\"\"\"\n\n    def max(\n        self, array: np.ndarray, axis: int | None = None, keepdims: bool = False\n    ) -&gt; np.ndarray:\n        # Custom max implementation\n        return np.amax(array, axis=axis, keepdims=keepdims)\n\n    def min(\n        self, array: np.ndarray, axis: int | None = None, keepdims: bool = False\n    ) -&gt; np.ndarray:\n        # Custom min implementation\n        return np.amin(array, axis=axis, keepdims=keepdims)\n\n    # Implement other required methods...\n</code></pre>"},{"location":"uguide/computation/#working-with-different-array-types","title":"Working with Different Array Types","text":""},{"location":"uguide/computation/#regular-numpy-arrays","title":"Regular NumPy Arrays","text":"<pre><code>import numpy as np\nfrom batcharray import computation\n\n# Standard operations\ndata = np.random.randn(100, 10)\nmax_vals = computation.max(data, axis=0)\nmean_vals = computation.mean(data, axis=0)\n</code></pre>"},{"location":"uguide/computation/#masked-arrays","title":"Masked Arrays","text":"<p>Masked arrays are useful for handling missing or invalid data:</p> <pre><code>import numpy as np\nimport numpy.ma as ma\nfrom batcharray import computation\n\n# Create data with some missing values\ndata = ma.array(\n    [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]],\n    mask=[\n        [False, True, False],  # 2nd value is masked\n        [False, False, True],  # 3rd value is masked\n        [True, False, False],\n    ],  # 1st value is masked\n)\n\n# Operations automatically handle masked values\nmax_vals = computation.max(data, axis=0)\n# Result: [4.0, 8.0, 6.0] - ignoring masked values\n\nmean_vals = computation.mean(data, axis=0)\n# Result: [2.5, 5.0, 4.5] - mean of non-masked values only\n</code></pre>"},{"location":"uguide/computation/#advanced-features","title":"Advanced Features","text":""},{"location":"uguide/computation/#axis-operations","title":"Axis Operations","text":"<p>All operations support axis parameters:</p> <pre><code>import numpy as np\nfrom batcharray import computation\n\ndata = np.random.randn(4, 5, 6)\n\n# Operate on different axes\nmax_0 = computation.max(data, axis=0)  # Shape: (5, 6)\nmax_1 = computation.max(data, axis=1)  # Shape: (4, 6)\nmax_all = computation.max(data, axis=None)  # Scalar\n</code></pre>"},{"location":"uguide/computation/#keepdims","title":"Keepdims","text":"<p>Preserve dimensions after reduction:</p> <pre><code>import numpy as np\nfrom batcharray import computation\n\ndata = np.array([[1, 2, 3], [4, 5, 6]])\n\n# Without keepdims\nresult1 = computation.max(data, axis=0)  # Shape: (3,)\n\n# With keepdims\nresult2 = computation.max(data, axis=0, keepdims=True)  # Shape: (1, 3)\n</code></pre>"},{"location":"uguide/computation/#integration-with-other-modules","title":"Integration with Other Modules","text":"<p>Computation models integrate seamlessly with other batcharray modules:</p> <pre><code>import numpy as np\nimport numpy.ma as ma\nfrom batcharray import array, computation\n\n# Create masked array batch\nbatch = ma.array(\n    [[1, 2, 3], [4, 5, 6], [7, 8, 9]], mask=[[0, 1, 0], [1, 0, 1], [0, 0, 0]]\n)\n\n# Use array operations (they use computation models internally)\nsliced = array.slice_along_batch(batch, stop=2)\nmax_vals = array.amax_along_batch(batch)  # Uses computation.max internally\n</code></pre>"},{"location":"uguide/computation/#common-patterns","title":"Common Patterns","text":""},{"location":"uguide/computation/#data-validation","title":"Data Validation","text":"<pre><code>import numpy as np\nimport numpy.ma as ma\nfrom batcharray import computation\n\n# Load data with potential invalid values\ndata = np.array([[1.0, -999.0, 3.0], [4.0, 5.0, -999.0]])\n\n# Mask invalid values\nmasked_data = ma.masked_equal(data, -999.0)\n\n# Compute statistics safely\nmean = computation.mean(masked_data, axis=0)\nmax_val = computation.max(masked_data, axis=0)\n</code></pre>"},{"location":"uguide/computation/#batch-processing-with-missing-data","title":"Batch Processing with Missing Data","text":"<pre><code>import numpy as np\nimport numpy.ma as ma\nfrom batcharray import computation, array\n\n# Batch with some missing values\nbatch = ma.array(\n    np.random.randn(100, 50), mask=np.random.random((100, 50)) &lt; 0.1  # 10% missing\n)\n\n# Process batch\nbatch_means = computation.mean(batch, axis=1)  # Mean per sample\nsorted_batch = computation.sort(batch, axis=1)  # Sort each sample\n</code></pre>"},{"location":"uguide/computation/#complete-function-reference","title":"Complete Function Reference","text":"<p>The <code>computation</code> module provides the following functions through its interface:</p>"},{"location":"uguide/computation/#statistical-operations","title":"Statistical Operations","text":"<ul> <li><code>max(array, axis, keepdims)</code> - Maximum values</li> <li><code>min(array, axis, keepdims)</code> - Minimum values</li> <li><code>mean(array, axis, keepdims)</code> - Mean values</li> <li><code>median(array, axis, keepdims)</code> - Median values</li> </ul>"},{"location":"uguide/computation/#indexing-operations","title":"Indexing Operations","text":"<ul> <li><code>argmax(array, axis)</code> - Indices of maximum values</li> <li><code>argmin(array, axis)</code> - Indices of minimum values</li> </ul>"},{"location":"uguide/computation/#sorting-operations","title":"Sorting Operations","text":"<ul> <li><code>sort(array, axis, kind)</code> - Sort array</li> <li><code>argsort(array, axis, kind)</code> - Get sorting indices</li> </ul>"},{"location":"uguide/computation/#joining-operations","title":"Joining Operations","text":"<ul> <li><code>concatenate(arrays, axis)</code> - Concatenate arrays</li> </ul>"},{"location":"uguide/computation/#available-models","title":"Available Models","text":"<p>The following computation models are available:</p> <ol> <li>BaseComputationModel - Abstract base class for creating custom models</li> <li>ArrayComputationModel - For regular NumPy arrays</li> <li>MaskedArrayComputationModel - For NumPy masked arrays</li> <li>AutoComputationModel - Automatically selects appropriate model</li> </ol>"},{"location":"uguide/computation/#creating-custom-models","title":"Creating Custom Models","text":"<p>You can extend <code>BaseComputationModel</code> to create custom computation models:</p> <pre><code>from typing import Sequence\n\nfrom numpy.typing import DTypeLike\nfrom batcharray.computation import BaseComputationModel\nimport numpy as np\n\n\nfrom batcharray.types import SortKind\n\n\nclass MyCustomArrayType(np.ndarray): ...\n\n\nclass CustomComputationModel(BaseComputationModel):\n    \"\"\"Custom computation model example.\"\"\"\n\n    def max(\n        self, arr: MyCustomArrayType, axis: int | None = None, *, keepdims: bool = False\n    ):\n        # Custom implementation\n        result = np.amax(arr, axis=axis, keepdims=keepdims)\n        # Add custom logic here\n        return result\n\n    def min(\n        self, arr: MyCustomArrayType, axis: int | None = None, *, keepdims: bool = False\n    ):\n        pass\n\n    def argmin(\n        self, arr: MyCustomArrayType, axis: int | None = None, *, keepdims: bool = False\n    ) -&gt; MyCustomArrayType:\n        raise NotImplementedError\n\n    def argsort(\n        self,\n        arr: MyCustomArrayType,\n        axis: int | None = None,\n        *,\n        kind: SortKind | None = None\n    ) -&gt; MyCustomArrayType:\n        raise NotImplementedError\n\n    def concatenate(\n        self,\n        arrays: Sequence[MyCustomArrayType],\n        axis: int | None = None,\n        *,\n        dtype: DTypeLike = None\n    ) -&gt; MyCustomArrayType:\n        raise NotImplementedError\n\n    def mean(\n        self, arr: MyCustomArrayType, axis: int | None = None, *, keepdims: bool = False\n    ) -&gt; MyCustomArrayType:\n        raise NotImplementedError\n\n    def median(\n        self, arr: MyCustomArrayType, axis: int | None = None, *, keepdims: bool = False\n    ) -&gt; MyCustomArrayType:\n        raise NotImplementedError\n\n    def sort(\n        self,\n        arr: MyCustomArrayType,\n        axis: int | None = None,\n        *,\n        kind: SortKind | None = None\n    ) -&gt; MyCustomArrayType:\n        raise NotImplementedError\n\n    def argmax(\n        self, arr: MyCustomArrayType, axis: int | None = None, *, keepdims: bool = False\n    ) -&gt; MyCustomArrayType:\n        raise NotImplementedError\n</code></pre>"},{"location":"uguide/computation/#registering-custom-models","title":"Registering Custom Models","text":"<p>Register custom models with <code>AutoComputationModel</code>:</p> <p>```python continuation import numpy as np from batcharray.computation import AutoComputationModel</p>"},{"location":"uguide/computation/#register-your-custom-model","title":"Register your custom model","text":"<p>AutoComputationModel.add_computation_model(MyCustomArrayType, CustomComputationModel())</p>"},{"location":"uguide/computation/#autocomputationmodel-will-now-use-your-custom-model-for-mycustomarraytype","title":"AutoComputationModel will now use your custom model for MyCustomArrayType","text":"<p>auto_model = AutoComputationModel() result = auto_model.max(MyCustomArrayType([1, 2, 3]), axis=0) <pre><code>## When to Use Computation Models\n\nUse computation models when:\n\n1. **Low-level operations** - You need fine-grained control over array operations\n2. **Custom array types** - Working with specialized array types beyond NumPy arrays\n3. **Abstraction** - Building libraries that should work with multiple array backends\n4. **Testing** - Mocking array operations for unit tests\n\nFor most use cases, prefer the higher-level `array` and `nested` modules which internally use computation models.\n\n## Integration with Array Module\n\nThe `array` module uses computation models internally:\n\n```python\nimport numpy as np\nfrom batcharray import array\n\n# This internally uses computation models\nbatch = np.array([[1, 2, 3], [4, 5, 6]])\nmax_vals = array.amax_along_batch(batch)\n\n# Equivalent low-level operation\nfrom batcharray.computation import AutoComputationModel\n\nmodel = AutoComputationModel()\nmax_vals = model.max(batch, axis=0)\n</code></pre></p> <p>For detailed API documentation, see the computation API reference.</p>"},{"location":"uguide/nested/","title":"Nested Data Structures","text":"<p>The <code>batcharray.nested</code> module provides functions to manipulate nested data structures containing NumPy arrays. This is particularly useful when working with complex data like dictionaries or lists of arrays that represent batches or sequences.</p>"},{"location":"uguide/nested/#overview","title":"Overview","text":"<p>When working with machine learning or data processing pipelines, you often have data organized in nested structures:</p> <ul> <li>Dictionaries with multiple arrays (e.g., features, labels, metadata)</li> <li>Lists or tuples of arrays</li> <li>Combinations of both</li> </ul> <p>The <code>nested</code> module allows you to apply batch or sequence operations to all arrays in these structures simultaneously.</p>"},{"location":"uguide/nested/#working-with-dictionaries","title":"Working with Dictionaries","text":""},{"location":"uguide/nested/#basic-operations","title":"Basic Operations","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\n# Create a batch as a dictionary\nbatch = {\n    \"features\": np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]),\n    \"labels\": np.array([0, 1, 0, 1, 0]),\n    \"weights\": np.array([1.0, 2.0, 1.5, 2.5, 1.0]),\n}\n\n# Slice all arrays in the batch\nsliced = nested.slice_along_batch(batch, stop=3)\n# Result: {\n#     \"features\": [[1, 2], [3, 4], [5, 6]],\n#     \"labels\": [0, 1, 0],\n#     \"weights\": [1.0, 2.0, 1.5]\n# }\n\n# Split into multiple batches\nbatches = nested.split_along_batch(batch, split_size_or_sections=2)\n# Returns list of 3 dictionaries, each with 2, 2, and 1 items\n</code></pre>"},{"location":"uguide/nested/#indexing-and-selection","title":"Indexing and Selection","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\nbatch = {\n    \"data\": np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),\n    \"mask\": np.array([True, False, True]),\n}\n\n# Select specific indices\nindices = np.array([0, 2])\nselected = nested.index_select_along_batch(batch, indices=indices)\n# Result: {\n#     \"data\": [[1, 2, 3], [7, 8, 9]],\n#     \"mask\": [True, True]\n# }\n\n# Select using boolean mask\nmask = np.array([True, False, True])\nmasked = nested.masked_select_along_batch(batch, mask=mask)\n</code></pre>"},{"location":"uguide/nested/#combining-and-concatenating","title":"Combining and Concatenating","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\nbatch1 = {\"x\": np.array([[1, 2], [3, 4]]), \"y\": np.array([0, 1])}\n\nbatch2 = {\"x\": np.array([[5, 6], [7, 8]]), \"y\": np.array([1, 0])}\n\n# Concatenate batches\ncombined = nested.concatenate_along_batch([batch1, batch2])\n# Result: {\n#     \"x\": [[1, 2], [3, 4], [5, 6], [7, 8]],\n#     \"y\": [0, 1, 1, 0]\n# }\n</code></pre>"},{"location":"uguide/nested/#sequence-operations","title":"Sequence Operations","text":"<p>Just like with arrays, you can perform sequence operations on nested structures:</p> <pre><code>import numpy as np\nfrom batcharray import nested\n\nsequences = {\n    \"inputs\": np.array(\n        [\n            [[1, 2], [3, 4], [5, 6]],  # Sequence 1\n            [[7, 8], [9, 10], [11, 12]],  # Sequence 2\n        ]\n    ),\n    \"targets\": np.array([[[0], [1], [0]], [[1], [1], [0]]]),\n}\n\n# Slice sequences\nsliced = nested.slice_along_seq(sequences, start=1)\n# Takes timesteps 1 and 2 from both arrays\n\n# Chunk sequences\nchunks = nested.chunk_along_seq(sequences, chunks=3)\n# Splits each sequence into 3 parts\n</code></pre>"},{"location":"uguide/nested/#reductions-and-statistics","title":"Reductions and Statistics","text":"<p>Compute statistics across nested structures:</p> <pre><code>import numpy as np\nfrom batcharray import nested\n\nbatch = {\n    \"scores\": np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]),\n    \"values\": np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]),\n}\n\n# Compute mean along batch\nmeans = nested.mean_along_batch(batch)\n# Result: {\n#     \"scores\": [2.5, 3.5, 4.5],\n#     \"values\": [0.25, 0.35, 0.45]\n# }\n\n# Find maximum values\nmaxes = nested.amax_along_batch(batch)\n</code></pre>"},{"location":"uguide/nested/#mathematical-operations","title":"Mathematical Operations","text":"<p>Apply mathematical operations element-wise to all arrays:</p> <pre><code>import numpy as np\nfrom batcharray import nested\n\ndata = {\n    \"angles\": np.array([[0.1, np.pi / 2], [np.pi, 3 * np.pi / 2]]),\n    \"values\": np.array([[1, -2], [3, -4]]),\n}\n\n# Apply trigonometric functions\nsines = nested.sin(data[\"angles\"])\ncosines = nested.cos(data[\"angles\"])\n\n# Apply other math functions\nabsolute = nested.abs(data)\n# Result: {\n#     \"angles\": [[0.1, \u03c0/2], [\u03c0, 3\u03c0/2]],\n#     \"values\": [[1, 2], [3, 4]]  # Absolute values\n# }\n\nexponential = nested.exp(data)\nlogarithm = nested.log(nested.abs(data))\nclipped = nested.clip(data, -2, 2)\n</code></pre>"},{"location":"uguide/nested/#shuffling-and-permutation","title":"Shuffling and Permutation","text":"<p>Randomly shuffle or permute data while maintaining relationships:</p> <pre><code>import numpy as np\nfrom batcharray import nested\n\nbatch = {\n    \"images\": np.random.randn(100, 28, 28),\n    \"labels\": np.random.randint(0, 10, 100),\n}\n\n# Shuffle all arrays with the same permutation\nshuffled = nested.shuffle_along_batch(batch)\n# Images and labels are shuffled together\n\n# Or provide your own permutation\nperm = np.random.permutation(100)\npermuted = nested.permute_along_batch(batch, permutation=perm)\n</code></pre>"},{"location":"uguide/nested/#sorting","title":"Sorting","text":"<p>Sort nested structures by values in one array:</p> <pre><code>import numpy as np\nfrom batcharray import nested\n\nbatch = {\n    \"scores\": np.array([3.0, 1.0, 4.0, 2.0]),\n    \"names\": np.array([\"Alice\", \"Bob\", \"Charlie\", \"David\"]),\n}\n\n# Get sorting indices for scores\nindices = nested.argsort_along_batch(batch[\"scores\"])\n\n# Sort all arrays by the scores\nsorted_batch = nested.take_along_batch(batch, indices=indices)\n# Result: scores [1.0, 2.0, 3.0, 4.0], names [\"Bob\", \"David\", \"Alice\", \"Charlie\"]\n</code></pre>"},{"location":"uguide/nested/#converting-to-lists","title":"Converting to Lists","text":"<p>Convert nested structures to native Python lists:</p> <pre><code>import numpy as np\nfrom batcharray import nested\n\nbatch = {\"data\": np.array([[1, 2], [3, 4]]), \"info\": np.array([True, False])}\n\n# Convert to lists recursively\nas_lists = nested.to_list(batch)\n# Result: {\n#     \"data\": [[1, 2], [3, 4]],\n#     \"info\": [True, False]\n# }\n</code></pre>"},{"location":"uguide/nested/#common-use-cases","title":"Common Use Cases","text":""},{"location":"uguide/nested/#machine-learning-pipelines","title":"Machine Learning Pipelines","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\n# Training data batch\nbatch = {\n    \"inputs\": np.random.randn(32, 784),  # MNIST-like data\n    \"labels\": np.random.randint(0, 10, 32),\n    \"sample_weights\": np.random.rand(32),\n}\n\n# Create train/val split\ntrain_batch = nested.slice_along_batch(batch, stop=24)\nval_batch = nested.slice_along_batch(batch, start=24)\n</code></pre>"},{"location":"uguide/nested/#data-augmentation","title":"Data Augmentation","text":"<pre><code>import numpy as np\nfrom batcharray import nested\n\n# Original batch\nbatch = {\"images\": np.random.randn(16, 28, 28), \"labels\": np.random.randint(0, 10, 16)}\n\n# Shuffle for data augmentation\naugmented = nested.shuffle_along_batch(batch)\n\n# Split into mini-batches\nmini_batches = nested.split_along_batch(augmented, split_size_or_sections=4)\n</code></pre>"},{"location":"uguide/nested/#function-reference","title":"Function Reference","text":"<p>The <code>nested</code> module provides all operations from the <code>array</code> module, but for nested structures. Here's a non comprehensive list organized by category:</p>"},{"location":"uguide/nested/#comparison-and-sorting","title":"Comparison and Sorting","text":"<ul> <li><code>argsort_along_batch()</code> - Get sorting indices (batch)</li> <li><code>argsort_along_seq()</code> - Get sorting indices (sequence)</li> <li><code>sort_along_batch()</code> - Sort nested arrays (batch)</li> <li><code>sort_along_seq()</code> - Sort nested arrays (sequence)</li> </ul>"},{"location":"uguide/nested/#conversion","title":"Conversion","text":"<ul> <li><code>to_list()</code> - Convert arrays to native Python lists</li> </ul>"},{"location":"uguide/nested/#indexing-and-selection_1","title":"Indexing and Selection","text":"<ul> <li><code>index_select_along_batch()</code> - Select using indices (batch)</li> <li><code>index_select_along_seq()</code> - Select using indices (sequence)</li> <li><code>masked_select_along_batch()</code> - Select using mask (batch)</li> <li><code>masked_select_along_seq()</code> - Select using mask (sequence)</li> <li><code>take_along_batch()</code> - Take elements using index array (batch)</li> <li><code>take_along_seq()</code> - Take elements using index array (sequence)</li> </ul>"},{"location":"uguide/nested/#joining-operations","title":"Joining Operations","text":"<ul> <li><code>concatenate_along_batch()</code> - Concatenate nested structures (batch)</li> <li><code>concatenate_along_seq()</code> - Concatenate nested structures (sequence)</li> <li><code>tile_along_seq()</code> - Tile nested arrays along sequence</li> </ul>"},{"location":"uguide/nested/#mathematical-operations_1","title":"Mathematical Operations","text":"<ul> <li><code>cumprod_along_batch()</code> - Cumulative product (batch)</li> <li><code>cumprod_along_seq()</code> - Cumulative product (sequence)</li> <li><code>cumsum_along_batch()</code> - Cumulative sum (batch)</li> <li><code>cumsum_along_seq()</code> - Cumulative sum (sequence)</li> </ul>"},{"location":"uguide/nested/#permutation-and-shuffling","title":"Permutation and Shuffling","text":"<ul> <li><code>permute_along_batch()</code> - Apply permutation (batch)</li> <li><code>permute_along_seq()</code> - Apply permutation (sequence)</li> <li><code>shuffle_along_batch()</code> - Random shuffle (batch)</li> <li><code>shuffle_along_seq()</code> - Random shuffle (sequence)</li> </ul>"},{"location":"uguide/nested/#pointwise-operations","title":"Pointwise Operations","text":"<ul> <li><code>abs()</code> - Absolute value</li> <li><code>clip()</code> - Clip values to range</li> <li><code>exp()</code> - Exponential (base e)</li> <li><code>exp2()</code> - Exponential (base 2)</li> <li><code>expm1()</code> - exp(x) - 1</li> <li><code>log()</code> - Natural logarithm</li> <li><code>log1p()</code> - log(1 + x)</li> <li><code>log2()</code> - Base-2 logarithm</li> <li><code>log10()</code> - Base-10 logarithm</li> </ul>"},{"location":"uguide/nested/#reduction-operations","title":"Reduction Operations","text":"<ul> <li><code>amax_along_batch()</code> / <code>max_along_batch()</code> - Maximum (batch)</li> <li><code>amax_along_seq()</code> / <code>max_along_seq()</code> - Maximum (sequence)</li> <li><code>amin_along_batch()</code> / <code>min_along_batch()</code> - Minimum (batch)</li> <li><code>amin_along_seq()</code> / <code>min_along_seq()</code> - Minimum (sequence)</li> <li><code>argmax_along_batch()</code> - Indices of maximum (batch)</li> <li><code>argmax_along_seq()</code> - Indices of maximum (sequence)</li> <li><code>argmin_along_batch()</code> - Indices of minimum (batch)</li> <li><code>argmin_along_seq()</code> - Indices of minimum (sequence)</li> <li><code>mean_along_batch()</code> - Mean (batch)</li> <li><code>mean_along_seq()</code> - Mean (sequence)</li> <li><code>median_along_batch()</code> - Median (batch)</li> <li><code>median_along_seq()</code> - Median (sequence)</li> <li><code>prod_along_batch()</code> - Product (batch)</li> <li><code>prod_along_seq()</code> - Product (sequence)</li> <li><code>sum_along_batch()</code> - Sum (batch)</li> <li><code>sum_along_seq()</code> - Sum (sequence)</li> </ul>"},{"location":"uguide/nested/#slicing-operations","title":"Slicing Operations","text":"<ul> <li><code>chunk_along_batch()</code> - Split into chunks (batch)</li> <li><code>chunk_along_seq()</code> - Split into chunks (sequence)</li> <li><code>select_along_batch()</code> - Select single index (batch)</li> <li><code>select_along_seq()</code> - Select single index (sequence)</li> <li><code>slice_along_batch()</code> - Slice range (batch)</li> <li><code>slice_along_seq()</code> - Slice range (sequence)</li> <li><code>split_along_batch()</code> - Split into sections (batch)</li> <li><code>split_along_seq()</code> - Split into sections (sequence)</li> </ul>"},{"location":"uguide/nested/#trigonometric-functions","title":"Trigonometric Functions","text":"<ul> <li><code>sin()</code> - Sine</li> <li><code>cos()</code> - Cosine</li> <li><code>tan()</code> - Tangent</li> <li><code>arcsin()</code> - Inverse sine</li> <li><code>arccos()</code> - Inverse cosine</li> <li><code>arctan()</code> - Inverse tangent</li> <li><code>sinh()</code> - Hyperbolic sine</li> <li><code>cosh()</code> - Hyperbolic cosine</li> <li><code>tanh()</code> - Hyperbolic tangent</li> <li><code>arcsinh()</code> - Inverse hyperbolic sine</li> <li><code>arccosh()</code> - Inverse hyperbolic cosine</li> <li><code>arctanh()</code> - Inverse hyperbolic tangent</li> </ul> <p>For detailed API documentation, see the nested API reference.</p>"}]}