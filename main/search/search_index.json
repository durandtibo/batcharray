{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p><code>batcharray</code> is lightweight library built on top of NumPy to manipulate nested data structure with NumPy arrays. This library provides functions for arrays where the first dimension is the batch dimension. It also provides functions for arrays representing a batch of sequences where the first dimension is the batch dimension and the second dimension is the sequence dimension.</p>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>batcharray</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>batcharray</code> to a new version will possibly break any code that was using the old version of <code>batcharray</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>batcharray</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-recommended","title":"Installing with <code>pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>pip install batcharray\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>batcharray</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code>pip install 'batcharray[all]'\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>batcharray</code> from source, you can follow the steps below. First, you will need to install <code>poetry</code>. <code>poetry</code> is used to manage and install the dependencies. If <code>poetry</code> is already installed on your machine, you can skip this step. There are several ways to install <code>poetry</code> so you can use the one that you prefer. You can check the <code>poetry</code> installation by running the following command:</p> <pre><code>poetry --version\n</code></pre> <p>Then, you can clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/batcharray.git\n</code></pre> <p>It is recommended to create a Python 3.8+ virtual environment. This step is optional so you can skip it. To create a virtual environment, you can use the following command:</p> <pre><code>make conda\n</code></pre> <p>It automatically creates a conda virtual environment. When the virtual environment is created, you can activate it with the following command:</p> <pre><code>conda activate batcharray\n</code></pre> <p>This example uses <code>conda</code> to create a virtual environment, but you can use other tools or configurations. Then, you should install the required package to use <code>batcharray</code> with the following command:</p> <pre><code>make install\n</code></pre> <p>This command will install all the required packages. You can also use this command to update the required packages. This command will check if there is a more recent package available and will install it. Finally, you can test the installation with the following command:</p> <pre><code>make unit-test-cov\n</code></pre>"},{"location":"refs/array/","title":"Array","text":""},{"location":"refs/array/#batcharray.array","title":"batcharray.array","text":"<p>Contain functions to manipulate arrays.</p>"},{"location":"refs/array/#batcharray.array.concatenate_along_batch","title":"batcharray.array.concatenate_along_batch","text":"<pre><code>concatenate_along_batch(\n    arrays: list[ndarray] | tuple[ndarray, ...]\n) -&gt; ndarray\n</code></pre> <p>Concatenate the given arrays in the batch axis.</p> <p>All arrays must either have the same data type and shape (except in the concatenating axis) or be empty.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>list[ndarray] | tuple[ndarray, ...]</code> <p>The arrays to concatenate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The concatenated arrays along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import concatenate_along_batch\n&gt;&gt;&gt; arrays = [\n...     np.array([[0, 1, 2], [4, 5, 6]]),\n...     np.array([[10, 11, 12], [13, 14, 15]]),\n... ]\n&gt;&gt;&gt; out = concatenate_along_batch(arrays)\n&gt;&gt;&gt; out\narray([[ 0,  1,  2],\n       [ 4,  5,  6],\n       [10, 11, 12],\n       [13, 14, 15]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.concatenate_along_seq","title":"batcharray.array.concatenate_along_seq","text":"<pre><code>concatenate_along_seq(\n    arrays: list[ndarray] | tuple[ndarray, ...]\n) -&gt; ndarray\n</code></pre> <p>Concatenate the given arrays in the sequence axis.</p> <p>All arrays must either have the same data type and shape (except in the concatenating axis) or be empty.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>list[ndarray] | tuple[ndarray, ...]</code> <p>The arrays to concatenate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The concatenated arrays along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import concatenate_along_seq\n&gt;&gt;&gt; arrays = [\n...     np.array([[0, 1, 2], [4, 5, 6]]),\n...     np.array([[10, 11], [12, 13]]),\n... ]\n&gt;&gt;&gt; out = concatenate_along_seq(arrays)\n&gt;&gt;&gt; out\narray([[ 0,  1,  2, 10, 11],\n       [ 4,  5,  6, 12, 13]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.cumprod_along_batch","title":"batcharray.array.cumprod_along_batch","text":"<pre><code>cumprod_along_batch(array: ndarray) -&gt; ndarray\n</code></pre> <p>Return the cumulative product of elements of input in the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The cumulative product of elements of input in the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import cumprod_along_batch\n&gt;&gt;&gt; array = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]])\n&gt;&gt;&gt; out = cumprod_along_batch(array)\n&gt;&gt;&gt; out\narray([[   1,    2], [   3,    8], [  15,   48], [ 105,  384], [ 945, 3840]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.cumprod_along_seq","title":"batcharray.array.cumprod_along_seq","text":"<pre><code>cumprod_along_seq(array: ndarray) -&gt; ndarray\n</code></pre> <p>Return the cumulative product of elements of input in the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The cumulative product of elements of input in the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import cumprod_along_seq\n&gt;&gt;&gt; array = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])\n&gt;&gt;&gt; out = cumprod_along_seq(array)\n&gt;&gt;&gt; out\narray([[    1,     2,     6,    24,   120],\n        [    6,    42,   336,  3024, 30240]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.cumsum_along_batch","title":"batcharray.array.cumsum_along_batch","text":"<pre><code>cumsum_along_batch(array: ndarray) -&gt; ndarray\n</code></pre> <p>Return the cumulative sum of elements of input in the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The cumulative sum of elements of input in the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import cumsum_along_batch\n&gt;&gt;&gt; array = np.arange(10).reshape(5, 2)\n&gt;&gt;&gt; out = cumsum_along_batch(array)\n&gt;&gt;&gt; out\narray([[ 0,  1], [ 2,  4], [ 6,  9], [12, 16], [20, 25]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.cumsum_along_seq","title":"batcharray.array.cumsum_along_seq","text":"<pre><code>cumsum_along_seq(array: ndarray) -&gt; ndarray\n</code></pre> <p>Return the cumulative sum of elements of input in the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The cumulative sum of elements of input in the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import cumsum_along_seq\n&gt;&gt;&gt; array = np.arange(10).reshape(2, 5)\n&gt;&gt;&gt; out = cumsum_along_seq(array)\n&gt;&gt;&gt; out\narray([[ 0,  1,  3,  6, 10],\n       [ 5, 11, 18, 26, 35]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.permute_along_batch","title":"batcharray.array.permute_along_batch","text":"<pre><code>permute_along_batch(\n    array: ndarray, permutation: ndarray\n) -&gt; ndarray\n</code></pre> <p>Permute the array along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The array to split.</p> required <code>permutation</code> <code>ndarray</code> <p>The 1-D array containing the indices of the permutation. The shape should match the batch axis of the array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The array with permuted data along the batch axis.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the shape of the permutation does not match the batch axis of the array.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import permute_along_batch\n&gt;&gt;&gt; array = np.arange(10).reshape(5, 2)\n&gt;&gt;&gt; out = permute_along_batch(array, np.array([2, 1, 3, 0, 4]))\n&gt;&gt;&gt; out\narray([[4, 5],\n       [2, 3],\n       [6, 7],\n       [0, 1],\n       [8, 9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.permute_along_seq","title":"batcharray.array.permute_along_seq","text":"<pre><code>permute_along_seq(\n    array: ndarray, permutation: ndarray\n) -&gt; ndarray\n</code></pre> <p>Permute the array along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The array to split.</p> required <code>permutation</code> <code>ndarray</code> <p>The 1-D array containing the indices of the permutation. The shape should match the sequence axis of the array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The array with permuted data along the sequence axis.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the shape of the permutation does not match the sequence axis of the array.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import permute_along_seq\n&gt;&gt;&gt; array = np.arange(10).reshape(2, 5)\n&gt;&gt;&gt; out = permute_along_seq(array, np.array([2, 1, 3, 0, 4]))\n&gt;&gt;&gt; out\narray([[2, 1, 3, 0, 4],\n       [7, 6, 8, 5, 9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.shuffle_along_batch","title":"batcharray.array.shuffle_along_batch","text":"<pre><code>shuffle_along_batch(\n    array: ndarray, rng: Generator | None = None\n) -&gt; ndarray\n</code></pre> <p>Shuffle the array along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The array to split.</p> required <code>rng</code> <code>Generator | None</code> <p>An optional random number generator.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The shuffled array.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import shuffle_along_batch\n&gt;&gt;&gt; array = np.arange(10).reshape(5, 2)\n&gt;&gt;&gt; out = shuffle_along_batch(array)\n&gt;&gt;&gt; out\narray([[...]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.shuffle_along_seq","title":"batcharray.array.shuffle_along_seq","text":"<pre><code>shuffle_along_seq(\n    array: ndarray, rng: Generator | None = None\n) -&gt; ndarray\n</code></pre> <p>Shuffle the array along the batch dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The array to split.</p> required <code>rng</code> <code>Generator | None</code> <p>An optional random number generator.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The shuffled array.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import shuffle_along_seq\n&gt;&gt;&gt; array = np.arange(10).reshape(2, 5)\n&gt;&gt;&gt; out = shuffle_along_seq(array)\n&gt;&gt;&gt; out\narray([[...]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.take_along_batch","title":"batcharray.array.take_along_batch","text":"<pre><code>take_along_batch(\n    array: ndarray, indices: ndarray\n) -&gt; ndarray\n</code></pre> <p>Return a new array which index the input array along the batch axis using the entries in <code>indices</code>.</p> Note <p>This function assumes the batch axis is the first axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>indices</code> <code>ndarray</code> <p>The 1-D array containing the indices to take.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The indicesed array along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import take_along_batch\n&gt;&gt;&gt; array = np.arange(10).reshape(5, 2)\n&gt;&gt;&gt; out = take_along_batch(array, np.array([2, 4]))\n&gt;&gt;&gt; out\narray([[4, 5],\n       [8, 9]])\n&gt;&gt;&gt; out = take_along_batch(array, np.array([4, 3, 2, 1, 0]))\n&gt;&gt;&gt; out\narray([[8, 9],\n       [6, 7],\n       [4, 5],\n       [2, 3],\n       [0, 1]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.take_along_seq","title":"batcharray.array.take_along_seq","text":"<pre><code>take_along_seq(array: ndarray, indices: ndarray) -&gt; ndarray\n</code></pre> <p>Return a new array which indiceses the input array along the sequence axis using the entries in <code>indices</code>.</p> Note <p>This function assumes the sequence axis is the second axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>indices</code> <code>ndarray</code> <p>The 1-D array containing the indices to take.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The indicesed array along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import take_along_seq\n&gt;&gt;&gt; array = np.arange(10).reshape(2, 5)\n&gt;&gt;&gt; out = take_along_seq(array, np.array([2, 4]))\n&gt;&gt;&gt; out\narray([[2, 4],\n       [7, 9]])\n&gt;&gt;&gt; out = take_along_seq(array, np.array([4, 3, 2, 1, 0]))\n&gt;&gt;&gt; out\narray([[4, 3, 2, 1, 0],\n       [9, 8, 7, 6, 5]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.tile_along_seq","title":"batcharray.array.tile_along_seq","text":"<pre><code>tile_along_seq(array: ndarray, reps: int) -&gt; ndarray\n</code></pre> <p>Construct an array by repeating the input array along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>reps</code> <code>int</code> <p>The number of repetitions data along the sequence axis.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A new array with the data repeated along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import tile_along_seq\n&gt;&gt;&gt; array = np.arange(10).reshape(2, 5)\n&gt;&gt;&gt; out = tile_along_seq(array, 2)\n&gt;&gt;&gt; out\narray([[0, 1, 2, 3, 4, 0, 1, 2, 3, 4],\n       [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]])\n</code></pre>"},{"location":"refs/nested/","title":"Nested","text":""},{"location":"refs/nested/#batcharray.nested","title":"batcharray.nested","text":"<p>Contain functions to manipulate nested data.</p>"},{"location":"refs/nested/#batcharray.nested.concatenate_along_batch","title":"batcharray.nested.concatenate_along_batch","text":"<pre><code>concatenate_along_batch(\n    data: Sequence[dict[Hashable, ndarray]]\n) -&gt; dict[Hashable, ndarray]\n</code></pre> <p>Concatenate the given arrays in the batch axis.</p> <p>All arrays must either have the same data type and shape (except in the concatenating axis) or be empty.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict[Hashable, ndarray]]</code> <p>The input data to concatenate. The dictionaries must have the same keys.</p> required <p>Returns:</p> Type Description <code>dict[Hashable, ndarray]</code> <p>The concatenated arrays along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import concatenate_along_batch\n&gt;&gt;&gt; data = [\n...     {\n...         \"a\": np.array([[0, 1, 2], [4, 5, 6]]),\n...         \"b\": np.array([[10, 11, 12], [13, 14, 15]]),\n...     },\n...     {\"a\": np.array([[7, 8, 9]]), \"b\": np.array([[17, 18, 19]])},\n... ]\n&gt;&gt;&gt; out = concatenate_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([[0, 1, 2], [4, 5, 6], [7, 8, 9]]),\n 'b': array([[10, 11, 12], [13, 14, 15], [17, 18, 19]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.concatenate_along_seq","title":"batcharray.nested.concatenate_along_seq","text":"<pre><code>concatenate_along_seq(\n    data: Sequence[dict[Hashable, ndarray]]\n) -&gt; dict[Hashable, ndarray]\n</code></pre> <p>Concatenate the given arrays in the sequence axis.</p> <p>All arrays must either have the same data type and shape (except in the concatenating axis) or be empty.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict[Hashable, ndarray]]</code> <p>The input data to concatenate. The dictionaries must have the same keys.</p> required <p>Returns:</p> Type Description <code>dict[Hashable, ndarray]</code> <p>The concatenated arrays along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import concatenate_along_seq\n&gt;&gt;&gt; data = [\n...     {\n...         \"a\": np.array([[0, 1, 2], [4, 5, 6]]),\n...         \"b\": np.array([[10, 11, 12], [13, 14, 15]]),\n...     },\n...     {\"a\": np.array([[7], [8]]), \"b\": np.array([[17], [18]])},\n... ]\n&gt;&gt;&gt; out = concatenate_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([[0, 1, 2, 7], [4, 5, 6, 8]]),\n 'b': array([[10, 11, 12, 17], [13, 14, 15, 18]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.take_along_batch","title":"batcharray.nested.take_along_batch","text":"<pre><code>take_along_batch(data: Any, indices: ndarray) -&gt; Any\n</code></pre> <p>Return the arrays which index the arrays along the batch axis using the entries in <code>indices</code>.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>indices</code> <code>ndarray</code> <p>The 1-D array containing the indices to take.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The indexed arrays along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import take_along_batch\n&gt;&gt;&gt; arrays = {\"a\": np.arange(10).reshape(5, 2), \"b\": np.array([4, 3, 2, 1, 0])}\n&gt;&gt;&gt; out = take_along_batch(arrays, np.array([2, 4]))\n&gt;&gt;&gt; out\n{'a': array([[4, 5], [8, 9]]), 'b': array([2, 0])}\n&gt;&gt;&gt; out = take_along_batch(arrays, np.array([4, 3, 2, 1, 0]))\n&gt;&gt;&gt; out\n{'a': array([[8, 9], [6, 7], [4, 5], [2, 3], [0, 1]]), 'b': array([0, 1, 2, 3, 4])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.take_along_seq","title":"batcharray.nested.take_along_seq","text":"<pre><code>take_along_seq(data: Any, indices: ndarray) -&gt; Any\n</code></pre> <p>Return the arrays which index the arrays along the sequence axis using the entries in <code>indices</code>.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>indices</code> <code>ndarray</code> <p>The 1-D array containing the indices to take.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The indexed arrays along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import take_along_seq\n&gt;&gt;&gt; arrays = {'a': np.arange(10).reshape(2, 5), 'b': np.array([[4, 3, 2, 1, 0]])}\n&gt;&gt;&gt; out = take_along_seq(arrays, np.array([2, 4]))\n&gt;&gt;&gt; out\n{'a': array([[2, 4], [7, 9]]), 'b': array([[2, 0]])}\n&gt;&gt;&gt; out = take_along_seq(arrays, np.array([4, 3, 2, 1, 0]))\n&gt;&gt;&gt; out\n{'a': array([[4, 3, 2, 1, 0], [9, 8, 7, 6, 5]]), 'b': array([[0, 1, 2, 3, 4]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.tile_along_seq","title":"batcharray.nested.tile_along_seq","text":"<pre><code>tile_along_seq(data: Any, reps: int) -&gt; Any\n</code></pre> <p>Repeat all the arrays along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>reps</code> <code>int</code> <p>The number of repetitions data along the sequence axis.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The arrays repeated along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import tile_along_seq\n&gt;&gt;&gt; data = {'a': np.arange(10).reshape(2, 5), 'b': np.array([[4, 3, 2, 1, 0]])}\n&gt;&gt;&gt; out = tile_along_seq(data, 2)\n&gt;&gt;&gt; out\n{'a': array([[0, 1, 2, 3, 4, 0, 1, 2, 3, 4], [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]]),\n 'b': array([[4, 3, 2, 1, 0, 4, 3, 2, 1, 0]])}\n</code></pre>"},{"location":"refs/recursive/","title":"Recursive","text":""},{"location":"refs/recursive/#batcharray.recursive","title":"batcharray.recursive","text":"<p>Contain features to easily work on nested objects.</p>"},{"location":"refs/recursive/#batcharray.recursive.ApplyState","title":"batcharray.recursive.ApplyState  <code>dataclass</code>","text":"<p>Store the current state.</p>"},{"location":"refs/recursive/#batcharray.recursive.AutoApplier","title":"batcharray.recursive.AutoApplier","text":"<p>             Bases: <code>BaseApplier[Any]</code></p> <p>Implement an applier that can automatically call other appliers based on the data type.</p>"},{"location":"refs/recursive/#batcharray.recursive.AutoApplier.add_applier","title":"batcharray.recursive.AutoApplier.add_applier  <code>classmethod</code>","text":"<pre><code>add_applier(\n    data_type: type,\n    applier: BaseApplier,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add an applier for a given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The data type for this test.</p> required <code>applier</code> <code>BaseApplier</code> <p>The applier object.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the data type already exists. This parameter should be set to <code>True</code> to overwrite the applier for a type.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a applier is already registered for the data type and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from batcharray.recursive import AutoApplier, SequenceApplier\n&gt;&gt;&gt; AutoApplier.add_applier(list, SequenceApplier(), exist_ok=True)\n</code></pre>"},{"location":"refs/recursive/#batcharray.recursive.AutoApplier.find_applier","title":"batcharray.recursive.AutoApplier.find_applier  <code>classmethod</code>","text":"<pre><code>find_applier(data_type: Any) -&gt; BaseApplier\n</code></pre> <p>Find the applier associated to an object.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>Any</code> <p>The data type to get.</p> required <p>Returns:</p> Type Description <code>BaseApplier</code> <p>The applier associated to the data type.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from batcharray.recursive import AutoApplier\n&gt;&gt;&gt; AutoApplier.find_applier(list)\nSequenceApplier()\n</code></pre>"},{"location":"refs/recursive/#batcharray.recursive.AutoApplier.has_applier","title":"batcharray.recursive.AutoApplier.has_applier  <code>classmethod</code>","text":"<pre><code>has_applier(data_type: type) -&gt; bool\n</code></pre> <p>Indicate if an applier is registered for the given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The data type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if an applier is registered, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from batcharray.recursive import AutoApplier\n&gt;&gt;&gt; AutoApplier.has_applier(list)\nTrue\n&gt;&gt;&gt; AutoApplier.has_applier(str)\nFalse\n</code></pre>"},{"location":"refs/recursive/#batcharray.recursive.BaseApplier","title":"batcharray.recursive.BaseApplier","text":"<p>             Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to implement a recursive applier.</p>"},{"location":"refs/recursive/#batcharray.recursive.BaseApplier.apply","title":"batcharray.recursive.BaseApplier.apply  <code>abstractmethod</code>","text":"<pre><code>apply(data: T, func: Callable, state: ApplyState) -&gt; T\n</code></pre> <p>Recursively apply a function on all the items in a nested data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The input data.</p> required <code>func</code> <code>Callable</code> <p>The function to apply on each item.</p> required <code>state</code> <code>ApplyState</code> <p>The current state.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The transformed data.</p>"},{"location":"refs/recursive/#batcharray.recursive.DefaultApplier","title":"batcharray.recursive.DefaultApplier","text":"<p>             Bases: <code>BaseApplier[Any]</code></p> <p>Define the default applier.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from batcharray.recursive import DefaultApplier, AutoApplier, ApplyState\n&gt;&gt;&gt; state = ApplyState(applier=AutoApplier())\n&gt;&gt;&gt; applier = DefaultApplier()\n&gt;&gt;&gt; applier\nDefaultApplier()\n&gt;&gt;&gt; out = applier.apply([1, \"abc\"], str, state)\n&gt;&gt;&gt; out\n\"[1, 'abc']\"\n</code></pre>"},{"location":"refs/recursive/#batcharray.recursive.MappingApplier","title":"batcharray.recursive.MappingApplier","text":"<p>             Bases: <code>BaseApplier[T]</code></p> <p>Define an applier for mappings/dictionaries.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from batcharray.recursive import MappingApplier, AutoApplier, ApplyState\n&gt;&gt;&gt; state = ApplyState(applier=AutoApplier())\n&gt;&gt;&gt; applier = MappingApplier()\n&gt;&gt;&gt; applier\nMappingApplier()\n&gt;&gt;&gt; out = applier.apply({\"a\": 1, \"b\": \"abc\"}, str, state)\n&gt;&gt;&gt; out\n{'a': '1', 'b': 'abc'}\n</code></pre>"},{"location":"refs/recursive/#batcharray.recursive.SequenceApplier","title":"batcharray.recursive.SequenceApplier","text":"<p>             Bases: <code>BaseApplier[T]</code></p> <p>Define a applier for sequences/lists/tuples.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from batcharray.recursive import SequenceApplier, AutoApplier, ApplyState\n&gt;&gt;&gt; state = ApplyState(applier=AutoApplier())\n&gt;&gt;&gt; applier = SequenceApplier()\n&gt;&gt;&gt; applier\nSequenceApplier()\n&gt;&gt;&gt; out = applier.apply([1, \"abc\"], str, state)\n&gt;&gt;&gt; out\n['1', 'abc']\n</code></pre>"},{"location":"refs/recursive/#batcharray.recursive.recursive_apply","title":"batcharray.recursive.recursive_apply","text":"<pre><code>recursive_apply(data: Any, func: Callable) -&gt; Any\n</code></pre> <p>Recursively apply a function on all the items in a nested data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data.</p> required <code>func</code> <code>Callable</code> <p>The function to apply on each item.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The transformed data.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from batcharray.recursive import recursive_apply\n&gt;&gt;&gt; out = recursive_apply({\"a\": 1, \"b\": \"abc\"}, str)\n&gt;&gt;&gt; out\n{'a': '1', 'b': 'abc'}\n</code></pre>"},{"location":"refs/utils/","title":"Utils","text":""},{"location":"refs/utils/#batcharray.utils","title":"batcharray.utils","text":"<p>Contain utility functions.</p>"},{"location":"refs/utils/#batcharray.utils.bfs_array","title":"batcharray.utils.bfs_array","text":"<pre><code>bfs_array(data: Any) -&gt; Generator[ndarray, None, None]\n</code></pre> <p>Implement a Breadth-First Search (BFS) iterator over the <code>numpy.ndarray</code>s.</p> <p>This function assumes the underlying data has a tree-like structure.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Specifies the data to iterate on.</p> required <p>Yields:</p> Type Description <code>ndarray</code> <p>The next <code>numpy.ndarray</code> in the data.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.utils import bfs_array\n&gt;&gt;&gt; list(bfs_array([\"abc\", np.ones((2, 3)), 42, np.arange(5)]))\n[array([[1., 1., 1.], [1., 1., 1.]]), array([0, 1, 2, 3, 4])]\n</code></pre>"},{"location":"uguide/array/","title":"Tensor","text":""},{"location":"uguide/array/#batch","title":"Batch","text":"<p><code>batcharray</code> provides functions to manipulate arrays representing a batch of examples. The functions assume the arrays have the following shape: <code>batch_size, *</code> where <code>*</code> means any axes.</p>"},{"location":"uguide/array/#sequence","title":"Sequence","text":"<p><code>batcharray</code> provides functions to manipulate arrays representing a batch of sequences. The functions assume the arrays have the following shape: <code>batch_size, seq_len, *</code> where <code>*</code> means any axes.</p>"}]}