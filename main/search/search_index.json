{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p><code>batcharray</code> is lightweight library built on top of NumPy to manipulate nested data structure with NumPy arrays. This library provides functions for arrays where the first axis is the batch axis. It also provides functions for arrays representing a batch of sequences where the first axis is the batch axis and the second axis is the sequence axis.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Let's imagine you have a batch which is represented by a dictionary with three arrays, and you want to take the first 2 items. <code>batcharray</code> provides the function <code>slice_along_batch</code> that allows to slide all the arrays:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import slice_along_batch\n&gt;&gt;&gt; batch = {\n...     \"a\": np.array([[2, 6], [0, 3], [4, 9], [8, 1], [5, 7]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n...     \"c\": np.array([1.0, 2.0, 3.0, 4.0, 5.0]),\n... }\n&gt;&gt;&gt; slice_along_batch(batch, stop=2)\n{'a': array([[2, 6], [0, 3]]), 'b': array([4, 3]), 'c': array([1., 2.])}\n</code></pre> <p>Similarly, it is possible to split a batch in multiple batches by using the function <code>split_along_batch</code>:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import split_along_batch\n&gt;&gt;&gt; batch = {\n...     \"a\": np.array([[2, 6], [0, 3], [4, 9], [8, 1], [5, 7]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n...     \"c\": np.array([1.0, 2.0, 3.0, 4.0, 5.0]),\n... }\n&gt;&gt;&gt; split_along_batch(batch, split_size_or_sections=2)\n[{'a': array([[2, 6], [0, 3]]), 'b': array([4, 3]), 'c': array([1., 2.])},\n {'a': array([[4, 9], [8, 1]]), 'b': array([2, 1]), 'c': array([3., 4.])},\n {'a': array([[5, 7]]), 'b': array([0]), 'c': array([5.])}]\n</code></pre> <p>Please check the documentation to see all the implemented functions.</p>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>batcharray</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>batcharray</code> to a new version will possibly break any code that was using the old version of <code>batcharray</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>batcharray</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-recommended","title":"Installing with <code>pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>pip install batcharray\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>batcharray</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code>pip install 'batcharray[all]'\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>batcharray</code> from source, you can follow the steps below. First, you will need to install <code>poetry</code>. <code>poetry</code> is used to manage and install the dependencies. If <code>poetry</code> is already installed on your machine, you can skip this step. There are several ways to install <code>poetry</code> so you can use the one that you prefer. You can check the <code>poetry</code> installation by running the following command:</p> <pre><code>poetry --version\n</code></pre> <p>Then, you can clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/batcharray.git\n</code></pre> <p>It is recommended to create a Python 3.8+ virtual environment. This step is optional so you can skip it. To create a virtual environment, you can use the following command:</p> <pre><code>make conda\n</code></pre> <p>It automatically creates a conda virtual environment. When the virtual environment is created, you can activate it with the following command:</p> <pre><code>conda activate batcharray\n</code></pre> <p>This example uses <code>conda</code> to create a virtual environment, but you can use other tools or configurations. Then, you should install the required package to use <code>batcharray</code> with the following command:</p> <pre><code>make install\n</code></pre> <p>This command will install all the required packages. You can also use this command to update the required packages. This command will check if there is a more recent package available and will install it. Finally, you can test the installation with the following command:</p> <pre><code>make unit-test-cov\n</code></pre>"},{"location":"refs/array/","title":"array","text":""},{"location":"refs/array/#batcharray.array","title":"batcharray.array","text":"<p>Contain functions to manipulate arrays.</p>"},{"location":"refs/array/#batcharray.array.amax_along_batch","title":"batcharray.array.amax_along_batch","text":"<pre><code>amax_along_batch(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the maximum of all elements along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The maximum of all elements along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import amax_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = amax_along_batch(array)\n&gt;&gt;&gt; out\narray([8, 9])\n&gt;&gt;&gt; out = amax_along_batch(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[8, 9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.amax_along_seq","title":"batcharray.array.amax_along_seq","text":"<pre><code>amax_along_seq(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the maximum of all elements along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The maximum of all elements along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import amax_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = amax_along_seq(array)\n&gt;&gt;&gt; out\narray([4, 9])\n&gt;&gt;&gt; out = amax_along_seq(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[4], [9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.amin_along_batch","title":"batcharray.array.amin_along_batch","text":"<pre><code>amin_along_batch(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the minimum of all elements along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The minimum of all elements along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import amin_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = amin_along_batch(array)\n&gt;&gt;&gt; out\narray([0, 1])\n&gt;&gt;&gt; out = amin_along_batch(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[0, 1]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.amin_along_seq","title":"batcharray.array.amin_along_seq","text":"<pre><code>amin_along_seq(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the minimum of all elements along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The minimum of all elements along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import amin_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = amin_along_seq(array)\n&gt;&gt;&gt; out\narray([0, 5])\n&gt;&gt;&gt; out = amin_along_seq(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[0], [5]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.argmax_along_batch","title":"batcharray.array.argmax_along_batch","text":"<pre><code>argmax_along_batch(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the indices of the maximum value of all elements along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The indices of the maximum value of all elements along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import argmax_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = argmax_along_batch(array)\n&gt;&gt;&gt; out\narray([4, 4])\n&gt;&gt;&gt; out = argmax_along_batch(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[4, 4]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.argmax_along_seq","title":"batcharray.array.argmax_along_seq","text":"<pre><code>argmax_along_seq(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the indices of the maximum value of all elements along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The indices of the maximum value of all elements along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import argmax_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = argmax_along_seq(array)\n&gt;&gt;&gt; out\narray([4, 4])\n&gt;&gt;&gt; out = argmax_along_seq(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[4], [4]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.argmin_along_batch","title":"batcharray.array.argmin_along_batch","text":"<pre><code>argmin_along_batch(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the indices of the minimum value of all elements along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The indices of the minimum value of all elements along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import argmin_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = argmin_along_batch(array)\n&gt;&gt;&gt; out\narray([0, 0])\n&gt;&gt;&gt; out = argmin_along_batch(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[0, 0]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.argmin_along_seq","title":"batcharray.array.argmin_along_seq","text":"<pre><code>argmin_along_seq(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the indices of the minimum value of all elements along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The indices of the minimum value of all elements along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import argmin_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = argmin_along_seq(array)\n&gt;&gt;&gt; out\narray([0, 0])\n&gt;&gt;&gt; out = argmin_along_seq(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[0], [0]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.argsort_along_batch","title":"batcharray.array.argsort_along_batch","text":"<pre><code>argsort_along_batch(\n    array: ndarray, kind: SortKind | None = None\n) -&gt; ndarray\n</code></pre> <p>Return the indices that sort an array along the batch axis in ascending order by value.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The indices that sort the array along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import argsort_along_batch\n&gt;&gt;&gt; array = np.array([[2, 6], [0, 3], [4, 9], [8, 1], [5, 7]])\n&gt;&gt;&gt; out = argsort_along_batch(array)\n&gt;&gt;&gt; out\narray([[1, 3], [0, 1], [2, 0], [4, 4], [3, 2]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.argsort_along_seq","title":"batcharray.array.argsort_along_seq","text":"<pre><code>argsort_along_seq(\n    array: ndarray, kind: SortKind | None = None\n) -&gt; ndarray\n</code></pre> <p>Return the indices that sort an array along the sequence axis in ascending order by value.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The indices that sort the array along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import argsort_along_seq\n&gt;&gt;&gt; array = np.array([[7, 3, 0, 8, 5], [1, 9, 6, 4, 2]])\n&gt;&gt;&gt; out = argsort_along_seq(array)\n&gt;&gt;&gt; out\narray([[2, 1, 4, 0, 3],\n       [0, 4, 3, 2, 1]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.chunk_along_batch","title":"batcharray.array.chunk_along_batch","text":"<pre><code>chunk_along_batch(\n    array: ndarray, chunks: int\n) -&gt; list[ndarray]\n</code></pre> <p>Split the array into chunks along the batch axis.</p> <p>Each chunk is a view of the input array.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The array to split.</p> required <code>chunks</code> <code>int</code> <p>Number of chunks to return.</p> required <p>Returns:</p> Type Description <code>list[ndarray]</code> <p>The array chunks.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import chunk_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; outputs = chunk_along_batch(array, chunks=3)\n&gt;&gt;&gt; outputs\n[array([[0, 1], [2, 3]]), array([[4, 5], [6, 7]]), array([[8, 9]])]\n</code></pre>"},{"location":"refs/array/#batcharray.array.chunk_along_seq","title":"batcharray.array.chunk_along_seq","text":"<pre><code>chunk_along_seq(\n    array: ndarray, chunks: int\n) -&gt; list[ndarray]\n</code></pre> <p>Split the array into chunks along the sequence axis.</p> <p>Each chunk is a view of the input array.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The array to split.</p> required <code>chunks</code> <code>int</code> <p>Number of chunks to return.</p> required <p>Returns:</p> Type Description <code>list[ndarray]</code> <p>The array chunks.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import chunk_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; outputs = chunk_along_seq(array, chunks=3)\n&gt;&gt;&gt; outputs\n[array([[0, 1], [5, 6]]), array([[2, 3], [7, 8]]), array([[4], [9]])]\n</code></pre>"},{"location":"refs/array/#batcharray.array.concatenate_along_batch","title":"batcharray.array.concatenate_along_batch","text":"<pre><code>concatenate_along_batch(\n    arrays: list[ndarray] | tuple[ndarray, ...],\n) -&gt; ndarray\n</code></pre> <p>Concatenate the given arrays in the batch axis.</p> <p>All arrays must either have the same data type and shape (except in the concatenating axis) or be empty.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>list[ndarray] | tuple[ndarray, ...]</code> <p>The arrays to concatenate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The concatenated arrays along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import concatenate_along_batch\n&gt;&gt;&gt; arrays = [\n...     np.array([[0, 1, 2], [4, 5, 6]]),\n...     np.array([[10, 11, 12], [13, 14, 15]]),\n... ]\n&gt;&gt;&gt; out = concatenate_along_batch(arrays)\n&gt;&gt;&gt; out\narray([[ 0,  1,  2],\n       [ 4,  5,  6],\n       [10, 11, 12],\n       [13, 14, 15]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.concatenate_along_seq","title":"batcharray.array.concatenate_along_seq","text":"<pre><code>concatenate_along_seq(\n    arrays: list[ndarray] | tuple[ndarray, ...],\n) -&gt; ndarray\n</code></pre> <p>Concatenate the given arrays in the sequence axis.</p> <p>All arrays must either have the same data type and shape (except in the concatenating axis) or be empty.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>list[ndarray] | tuple[ndarray, ...]</code> <p>The arrays to concatenate.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The concatenated arrays along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import concatenate_along_seq\n&gt;&gt;&gt; arrays = [\n...     np.array([[0, 1, 2], [4, 5, 6]]),\n...     np.array([[10, 11], [12, 13]]),\n... ]\n&gt;&gt;&gt; out = concatenate_along_seq(arrays)\n&gt;&gt;&gt; out\narray([[ 0,  1,  2, 10, 11],\n       [ 4,  5,  6, 12, 13]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.cumprod_along_batch","title":"batcharray.array.cumprod_along_batch","text":"<pre><code>cumprod_along_batch(array: ndarray) -&gt; ndarray\n</code></pre> <p>Return the cumulative product of elements of input in the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The cumulative product of elements of input in the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import cumprod_along_batch\n&gt;&gt;&gt; array = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]])\n&gt;&gt;&gt; out = cumprod_along_batch(array)\n&gt;&gt;&gt; out\narray([[   1,    2], [   3,    8], [  15,   48], [ 105,  384], [ 945, 3840]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.cumprod_along_seq","title":"batcharray.array.cumprod_along_seq","text":"<pre><code>cumprod_along_seq(array: ndarray) -&gt; ndarray\n</code></pre> <p>Return the cumulative product of elements of input in the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The cumulative product of elements of input in the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import cumprod_along_seq\n&gt;&gt;&gt; array = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])\n&gt;&gt;&gt; out = cumprod_along_seq(array)\n&gt;&gt;&gt; out\narray([[    1,     2,     6,    24,   120],\n        [    6,    42,   336,  3024, 30240]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.cumsum_along_batch","title":"batcharray.array.cumsum_along_batch","text":"<pre><code>cumsum_along_batch(array: ndarray) -&gt; ndarray\n</code></pre> <p>Return the cumulative sum of elements of input in the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The cumulative sum of elements of input in the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import cumsum_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = cumsum_along_batch(array)\n&gt;&gt;&gt; out\narray([[ 0,  1], [ 2,  4], [ 6,  9], [12, 16], [20, 25]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.cumsum_along_seq","title":"batcharray.array.cumsum_along_seq","text":"<pre><code>cumsum_along_seq(array: ndarray) -&gt; ndarray\n</code></pre> <p>Return the cumulative sum of elements of input in the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The cumulative sum of elements of input in the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import cumsum_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = cumsum_along_seq(array)\n&gt;&gt;&gt; out\narray([[ 0,  1,  3,  6, 10],\n       [ 5, 11, 18, 26, 35]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.index_select_along_batch","title":"batcharray.array.index_select_along_batch","text":"<pre><code>index_select_along_batch(\n    array: ndarray, indices: ndarray\n) -&gt; ndarray\n</code></pre> <p>Return a new array which indexes the input array along the batch axis using the entries in <code>indices</code>.</p> Note <p>This function assumes the batch axis is the first axis.</p> Note <p>Equivalent to <code>take_along_batch</code>.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>indices</code> <code>ndarray</code> <p>The 1-D array containing the indices to take.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The indexed array along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import index_select_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = index_select_along_batch(array, np.array([2, 4]))\n&gt;&gt;&gt; out\narray([[4, 5],\n       [8, 9]])\n&gt;&gt;&gt; out = index_select_along_batch(array, np.array([4, 3, 2, 1, 0]))\n&gt;&gt;&gt; out\narray([[8, 9],\n       [6, 7],\n       [4, 5],\n       [2, 3],\n       [0, 1]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.index_select_along_seq","title":"batcharray.array.index_select_along_seq","text":"<pre><code>index_select_along_seq(\n    array: ndarray, indices: ndarray\n) -&gt; ndarray\n</code></pre> <p>Return a new array which indexes the input array along the sequence axis using the entries in <code>indices</code>.</p> Note <p>This function assumes the sequence axis is the second axis.</p> Note <p>Equivalent to <code>take_along_seq</code>.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>indices</code> <code>ndarray</code> <p>The 1-D array containing the indices to take.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The indexed array along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import index_select_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = index_select_along_seq(array, np.array([2, 4]))\n&gt;&gt;&gt; out\narray([[2, 4],\n       [7, 9]])\n&gt;&gt;&gt; out = index_select_along_seq(array, np.array([4, 3, 2, 1, 0]))\n&gt;&gt;&gt; out\narray([[4, 3, 2, 1, 0],\n       [9, 8, 7, 6, 5]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.masked_select_along_batch","title":"batcharray.array.masked_select_along_batch","text":"<pre><code>masked_select_along_batch(\n    array: ndarray, mask: ndarray\n) -&gt; ndarray\n</code></pre> <p>Return a new array which indexes the input array along the batch axis according to the boolean mask <code>mask</code>.</p> Note <p>This function assumes the batch axis is the first axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>mask</code> <code>ndarray</code> <p>The 1-D array containing the binary mask to index with.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The indexed array along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import masked_select_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = masked_select_along_batch(array, np.array([False, False, True, False, True]))\n&gt;&gt;&gt; out\narray([[4, 5], [8, 9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.masked_select_along_seq","title":"batcharray.array.masked_select_along_seq","text":"<pre><code>masked_select_along_seq(\n    array: ndarray, mask: ndarray\n) -&gt; ndarray\n</code></pre> <p>Return a new array which indexes the input array along the sequence axis according to the boolean mask <code>mask</code>.</p> Note <p>This function assumes the batch axis is the first axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>mask</code> <code>ndarray</code> <p>The 1-D array containing the binary mask to index with.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The indexed array along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import masked_select_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = masked_select_along_seq(array, np.array([False, False, True, False, True]))\n&gt;&gt;&gt; out\narray([[2, 4], [7, 9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.max_along_batch","title":"batcharray.array.max_along_batch","text":"<pre><code>max_along_batch(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the maximum of all elements along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The maximum of the input array along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import max_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = max_along_batch(array)\n&gt;&gt;&gt; out\narray([8, 9])\n&gt;&gt;&gt; out = max_along_batch(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[8, 9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.max_along_seq","title":"batcharray.array.max_along_seq","text":"<pre><code>max_along_seq(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the maximum of all elements along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The minimum of the input array along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import max_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = max_along_seq(array)\n&gt;&gt;&gt; out\narray([4, 9])\n&gt;&gt;&gt; out = max_along_seq(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[4], [9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.mean_along_batch","title":"batcharray.array.mean_along_batch","text":"<pre><code>mean_along_batch(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the mean of all elements along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The mean of all elements along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import mean_along_batch\n&gt;&gt;&gt; array = np.array([[0.0, 1.0], [2.0, 3.0], [4.0, 5.0], [6.0, 7.0], [8.0, 9.0]])\n&gt;&gt;&gt; out = mean_along_batch(array)\n&gt;&gt;&gt; out\narray([4., 5.])\n&gt;&gt;&gt; out = mean_along_batch(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[4., 5.]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.mean_along_seq","title":"batcharray.array.mean_along_seq","text":"<pre><code>mean_along_seq(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the mean of all elements along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The mean of all elements along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import mean_along_seq\n&gt;&gt;&gt; array = np.array([[0.0, 1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0, 9.0]])\n&gt;&gt;&gt; out = mean_along_seq(array)\n&gt;&gt;&gt; out\narray([2., 7.])\n&gt;&gt;&gt; out = mean_along_seq(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[2.], [7.]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.median_along_batch","title":"batcharray.array.median_along_batch","text":"<pre><code>median_along_batch(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the median of all elements along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A new array holding the result. If the input contains integers or floats smaller than <code>np.float64</code>, then the output data-type is <code>np.float64</code>. Otherwise, the data-type of the output is the same as that of the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import median_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = median_along_batch(array)\n&gt;&gt;&gt; out\narray([4., 5.])\n&gt;&gt;&gt; out = median_along_batch(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[4., 5.]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.median_along_seq","title":"batcharray.array.median_along_seq","text":"<pre><code>median_along_seq(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the median of all elements along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A new array holding the result. If the input contains integers or floats smaller than <code>np.float64</code>, then the output data-type is <code>np.float64</code>. Otherwise, the data-type of the output is the same as that of the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import median_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = median_along_seq(array)\n&gt;&gt;&gt; out\narray([2., 7.])\n&gt;&gt;&gt; out = median_along_seq(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[2.], [7.]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.min_along_batch","title":"batcharray.array.min_along_batch","text":"<pre><code>min_along_batch(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the minimum of all elements along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The minimum of the input array along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import min_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = min_along_batch(array)\n&gt;&gt;&gt; out\narray([0, 1])\n&gt;&gt;&gt; out = min_along_batch(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[0, 1]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.min_along_seq","title":"batcharray.array.min_along_seq","text":"<pre><code>min_along_seq(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the minimum of all elements along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The minimum of the input array along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import min_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = min_along_seq(array)\n&gt;&gt;&gt; out\narray([0, 5])\n&gt;&gt;&gt; out = min_along_seq(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[0], [5]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.permute_along_batch","title":"batcharray.array.permute_along_batch","text":"<pre><code>permute_along_batch(\n    array: ndarray, permutation: ndarray\n) -&gt; ndarray\n</code></pre> <p>Permute the array along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The array to split.</p> required <code>permutation</code> <code>ndarray</code> <p>The 1-D array containing the indices of the permutation. The shape should match the batch axis of the array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The array with permuted data along the batch axis.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the shape of the permutation does not match the batch axis of the array.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import permute_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = permute_along_batch(array, np.array([2, 1, 3, 0, 4]))\n&gt;&gt;&gt; out\narray([[4, 5],\n       [2, 3],\n       [6, 7],\n       [0, 1],\n       [8, 9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.permute_along_seq","title":"batcharray.array.permute_along_seq","text":"<pre><code>permute_along_seq(\n    array: ndarray, permutation: ndarray\n) -&gt; ndarray\n</code></pre> <p>Permute the array along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The array to split.</p> required <code>permutation</code> <code>ndarray</code> <p>The 1-D array containing the indices of the permutation. The shape should match the sequence axis of the array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The array with permuted data along the sequence axis.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the shape of the permutation does not match the sequence axis of the array.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import permute_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = permute_along_seq(array, np.array([2, 1, 3, 0, 4]))\n&gt;&gt;&gt; out\narray([[2, 1, 3, 0, 4],\n       [7, 6, 8, 5, 9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.prod_along_batch","title":"batcharray.array.prod_along_batch","text":"<pre><code>prod_along_batch(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the product of all elements along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The product of all elements along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import prod_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = prod_along_batch(array)\n&gt;&gt;&gt; out\narray([  0, 945])\n&gt;&gt;&gt; out = prod_along_batch(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[  0, 945]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.prod_along_seq","title":"batcharray.array.prod_along_seq","text":"<pre><code>prod_along_seq(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the product of all elements along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The product of all elements along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import prod_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = prod_along_seq(array)\n&gt;&gt;&gt; out\narray([    0, 15120])\n&gt;&gt;&gt; out = prod_along_seq(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[    0], [15120]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.select_along_batch","title":"batcharray.array.select_along_batch","text":"<pre><code>select_along_batch(array: ndarray, index: int) -&gt; ndarray\n</code></pre> <p>Slice the input array along the batch axis at the given index.</p> <p>This function returns a view of the original array with the batch axis removed.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>index</code> <code>int</code> <p>The index to select with.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The sliced array along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import select_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = select_along_batch(array, index=2)\n&gt;&gt;&gt; out\narray([4, 5])\n</code></pre>"},{"location":"refs/array/#batcharray.array.select_along_seq","title":"batcharray.array.select_along_seq","text":"<pre><code>select_along_seq(array: ndarray, index: int) -&gt; ndarray\n</code></pre> <p>Slice the input array along the sequence axis at the given index.</p> <p>This function returns a view of the original array with the sequence axis removed.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>index</code> <code>int</code> <p>The index to select with.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The sliced array along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import select_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = select_along_seq(array, index=2)\n&gt;&gt;&gt; out\narray([2, 7])\n</code></pre>"},{"location":"refs/array/#batcharray.array.shuffle_along_batch","title":"batcharray.array.shuffle_along_batch","text":"<pre><code>shuffle_along_batch(\n    array: ndarray, rng: Generator | None = None\n) -&gt; ndarray\n</code></pre> <p>Shuffle the array along the batch dimension.</p> Note <p>This function assumes the batch axis is the first     dimension.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The array to split.</p> required <code>rng</code> <code>Generator | None</code> <p>An optional random number generator.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The shuffled array.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import shuffle_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = shuffle_along_batch(array)\n&gt;&gt;&gt; out\narray([[...]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.shuffle_along_seq","title":"batcharray.array.shuffle_along_seq","text":"<pre><code>shuffle_along_seq(\n    array: ndarray, rng: Generator | None = None\n) -&gt; ndarray\n</code></pre> <p>Shuffle the array along the batch dimension.</p> Note <p>This function assumes the sequence axis is the second     dimension.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The array to split.</p> required <code>rng</code> <code>Generator | None</code> <p>An optional random number generator.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The shuffled array.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import shuffle_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = shuffle_along_seq(array)\n&gt;&gt;&gt; out\narray([[...]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.slice_along_batch","title":"batcharray.array.slice_along_batch","text":"<pre><code>slice_along_batch(\n    array: ndarray,\n    start: int = 0,\n    stop: int | None = None,\n    step: int = 1,\n) -&gt; ndarray\n</code></pre> <p>Slice the array along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>start</code> <code>int</code> <p>The index where the slicing of object starts.</p> <code>0</code> <code>stop</code> <code>int | None</code> <p>The index where the slicing of object stops. <code>None</code> means last.</p> <code>None</code> <code>step</code> <code>int</code> <p>The increment between each index for slicing.</p> <code>1</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The sliced array along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import slice_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = slice_along_batch(array, start=2)\n&gt;&gt;&gt; out\narray([[4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = slice_along_batch(array, stop=3)\n&gt;&gt;&gt; out\narray([[0, 1], [2, 3], [4, 5]])\n&gt;&gt;&gt; out = slice_along_batch(array, step=2)\n&gt;&gt;&gt; out\narray([[0, 1], [4, 5], [8, 9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.slice_along_seq","title":"batcharray.array.slice_along_seq","text":"<pre><code>slice_along_seq(\n    array: ndarray,\n    start: int = 0,\n    stop: int | None = None,\n    step: int = 1,\n) -&gt; ndarray\n</code></pre> <p>Slice the array along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>start</code> <code>int</code> <p>The index where the slicing of object starts.</p> <code>0</code> <code>stop</code> <code>int | None</code> <p>The index where the slicing of object stops. <code>None</code> means last.</p> <code>None</code> <code>step</code> <code>int</code> <p>The increment between each index for slicing.</p> <code>1</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The sliced array along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import slice_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [9, 8, 7, 6, 5]])\n&gt;&gt;&gt; out = slice_along_seq(array, start=2)\n&gt;&gt;&gt; out\narray([[2, 3, 4], [7, 6, 5]])\n&gt;&gt;&gt; out = slice_along_seq(array, stop=3)\n&gt;&gt;&gt; out\narray([[0, 1, 2], [9, 8, 7]])\n&gt;&gt;&gt; out = slice_along_seq(array, step=2)\n&gt;&gt;&gt; out\narray([[0, 2, 4], [9, 7, 5]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.sort_along_batch","title":"batcharray.array.sort_along_batch","text":"<pre><code>sort_along_batch(\n    array: ndarray, kind: SortKind | None = None\n) -&gt; ndarray\n</code></pre> <p>Sort the elements of the input array along the batch axis in ascending order by value.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The sorted array along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import sort_along_batch\n&gt;&gt;&gt; array = np.array([[2, 6], [0, 3], [4, 9], [8, 1], [5, 7]])\n&gt;&gt;&gt; out = sort_along_batch(array)\n&gt;&gt;&gt; out\narray([[0, 1], [2, 3], [4, 6], [5, 7], [8, 9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.sort_along_seq","title":"batcharray.array.sort_along_seq","text":"<pre><code>sort_along_seq(\n    array: ndarray, kind: SortKind | None = None\n) -&gt; ndarray\n</code></pre> <p>Sort the elements of the input array along the sequence axis in ascending order by value.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The sorted array along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import sort_along_seq\n&gt;&gt;&gt; array = np.array([[7, 3, 0, 8, 5], [1, 9, 6, 4, 2]])\n&gt;&gt;&gt; out = sort_along_seq(array)\n&gt;&gt;&gt; out\narray([[0, 3, 5, 7, 8], [1, 2, 4, 6, 9]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.split_along_batch","title":"batcharray.array.split_along_batch","text":"<pre><code>split_along_batch(\n    array: ndarray,\n    split_size_or_sections: int | Sequence[int],\n) -&gt; list[ndarray]\n</code></pre> <p>Split the array into chunks along the batch axis.</p> <p>Each chunk is a view of the original array.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>split_size_or_sections</code> <code>int | Sequence[int]</code> <p>Size of a single chunk or list of sizes for each chunk</p> required <p>Returns:</p> Type Description <code>list[ndarray]</code> <p>The array chunks.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import split_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; outputs = split_along_batch(array, split_size_or_sections=2)\n&gt;&gt;&gt; outputs\n[array([[0, 1], [2, 3]]), array([[4, 5], [6, 7]]), array([[8, 9]])]\n</code></pre>"},{"location":"refs/array/#batcharray.array.split_along_seq","title":"batcharray.array.split_along_seq","text":"<pre><code>split_along_seq(\n    array: ndarray,\n    split_size_or_sections: int | Sequence[int],\n) -&gt; list[ndarray]\n</code></pre> <p>Split the array into chunks along the sequence axis.</p> <p>Each chunk is a view of the original array.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>split_size_or_sections</code> <code>int | Sequence[int]</code> <p>Size of a single chunk or list of sizes for each chunk</p> required <p>Returns:</p> Type Description <code>list[ndarray]</code> <p>The array chunks.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import split_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; outputs = split_along_seq(array, split_size_or_sections=2)\n&gt;&gt;&gt; outputs\n[array([[0, 1], [5, 6]]), array([[2, 3], [7, 8]]), array([[4], [9]])]\n</code></pre>"},{"location":"refs/array/#batcharray.array.sum_along_batch","title":"batcharray.array.sum_along_batch","text":"<pre><code>sum_along_batch(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the sum of all elements along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The sum of all elements along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import sum_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = sum_along_batch(array)\n&gt;&gt;&gt; out\narray([20, 25])\n&gt;&gt;&gt; out = sum_along_batch(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[20, 25]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.sum_along_seq","title":"batcharray.array.sum_along_seq","text":"<pre><code>sum_along_seq(\n    array: ndarray, keepdims: bool = False\n) -&gt; ndarray\n</code></pre> <p>Return the sum of all elements along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The sum of all elements along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import sum_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = sum_along_seq(array)\n&gt;&gt;&gt; out\narray([10, 35])\n&gt;&gt;&gt; out = sum_along_seq(array, keepdims=True)\n&gt;&gt;&gt; out\narray([[10], [35]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.take_along_batch","title":"batcharray.array.take_along_batch","text":"<pre><code>take_along_batch(\n    array: ndarray, indices: ndarray\n) -&gt; ndarray\n</code></pre> <p>Return a new array which indexes the input array along the batch axis using the entries in <code>indices</code>.</p> Note <p>This function assumes the batch axis is the first axis.</p> Note <p>Equivalent to <code>index_select_along_batch</code>.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>indices</code> <code>ndarray</code> <p>The 1-D array containing the indices to take.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The indexed array along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import take_along_batch\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = take_along_batch(array, np.array([2, 4]))\n&gt;&gt;&gt; out\narray([[4, 5],\n       [8, 9]])\n&gt;&gt;&gt; out = take_along_batch(array, np.array([4, 3, 2, 1, 0]))\n&gt;&gt;&gt; out\narray([[8, 9],\n       [6, 7],\n       [4, 5],\n       [2, 3],\n       [0, 1]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.take_along_seq","title":"batcharray.array.take_along_seq","text":"<pre><code>take_along_seq(array: ndarray, indices: ndarray) -&gt; ndarray\n</code></pre> <p>Return a new array which indexes the input array along the sequence axis using the entries in <code>indices</code>.</p> Note <p>This function assumes the sequence axis is the second axis.</p> Note <p>Equivalent to <code>index_select_along_seq</code>.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>indices</code> <code>ndarray</code> <p>The 1-D array containing the indices to take.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The indexed array along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import take_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = take_along_seq(array, np.array([2, 4]))\n&gt;&gt;&gt; out\narray([[2, 4],\n       [7, 9]])\n&gt;&gt;&gt; out = take_along_seq(array, np.array([4, 3, 2, 1, 0]))\n&gt;&gt;&gt; out\narray([[4, 3, 2, 1, 0],\n       [9, 8, 7, 6, 5]])\n</code></pre>"},{"location":"refs/array/#batcharray.array.tile_along_seq","title":"batcharray.array.tile_along_seq","text":"<pre><code>tile_along_seq(array: ndarray, reps: int) -&gt; ndarray\n</code></pre> <p>Construct an array by repeating the input array along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>reps</code> <code>int</code> <p>The number of repetitions data along the sequence axis.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A new array with the data repeated along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.array import tile_along_seq\n&gt;&gt;&gt; array = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; out = tile_along_seq(array, 2)\n&gt;&gt;&gt; out\narray([[0, 1, 2, 3, 4, 0, 1, 2, 3, 4],\n       [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]])\n</code></pre>"},{"location":"refs/computation/","title":"computation","text":""},{"location":"refs/computation/#batcharray.computation","title":"batcharray.computation","text":"<p>Contain the computation models.</p>"},{"location":"refs/computation/#batcharray.computation.ArrayComputationModel","title":"batcharray.computation.ArrayComputationModel","text":"<p>               Bases: <code>BaseComputationModel[ndarray]</code></p> <p>Implement a computation model for <code>numpy.ndarray</code>s.</p>"},{"location":"refs/computation/#batcharray.computation.AutoComputationModel","title":"batcharray.computation.AutoComputationModel","text":"<p>               Bases: <code>BaseComputationModel[T]</code></p> <p>Implement a computation model that automatically finds the right computation model based on the array type.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import AutoComputationModel\n&gt;&gt;&gt; comp_model = AutoComputationModel()\n&gt;&gt;&gt; arrays = [\n...     np.array([[0, 1, 2], [4, 5, 6]]),\n...     np.array([[10, 11, 12], [13, 14, 15]]),\n... ]\n&gt;&gt;&gt; out = comp_model.concatenate(arrays, axis=0)\n&gt;&gt;&gt; out\narray([[ 0,  1,  2],\n       [ 4,  5,  6],\n       [10, 11, 12],\n       [13, 14, 15]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.AutoComputationModel.add_computation_model","title":"batcharray.computation.AutoComputationModel.add_computation_model  <code>classmethod</code>","text":"<pre><code>add_computation_model(\n    array_type: type[ndarray],\n    comp_model: BaseComputationModel[T],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add a computation model for a given array type.</p> <p>Parameters:</p> Name Type Description Default <code>array_type</code> <code>type[ndarray]</code> <p>The array type.</p> required <code>comp_model</code> <code>BaseComputationModel[T]</code> <p>The computation model to use for the given array type.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the data type already exists. This parameter should be set to <code>True</code> to overwrite the computation model for an array type.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a computation model is already registered for the array type and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import AutoComputationModel, ArrayComputationModel\n&gt;&gt;&gt; AutoComputationModel.add_computation_model(\n...     np.ndarray, ArrayComputationModel(), exist_ok=True\n... )\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.AutoComputationModel.find_computation_model","title":"batcharray.computation.AutoComputationModel.find_computation_model  <code>classmethod</code>","text":"<pre><code>find_computation_model(\n    array_type: type[ndarray],\n) -&gt; BaseComputationModel[T]\n</code></pre> <p>Find the computation model associated to an array type.</p> <p>Parameters:</p> Name Type Description Default <code>array_type</code> <code>type[ndarray]</code> <p>The array type.</p> required <p>Returns:</p> Type Description <code>BaseComputationModel[T]</code> <p>The computation model associated to the array type.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import AutoComputationModel\n&gt;&gt;&gt; AutoComputationModel.find_computation_model(np.ndarray)\nArrayComputationModel()\n&gt;&gt;&gt; AutoComputationModel.find_computation_model(np.ma.MaskedArray)\nMaskedArrayComputationModel()\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.AutoComputationModel.has_computation_model","title":"batcharray.computation.AutoComputationModel.has_computation_model  <code>classmethod</code>","text":"<pre><code>has_computation_model(array_type: type[ndarray]) -&gt; bool\n</code></pre> <p>Indicate if a computation model is registered for the given array type.</p> <p>Parameters:</p> Name Type Description Default <code>array_type</code> <code>type[ndarray]</code> <p>The array type.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if a computation model is registered, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import AutoComputationModel\n&gt;&gt;&gt; AutoComputationModel.has_computation_model(np.ndarray)\nTrue\n&gt;&gt;&gt; AutoComputationModel.has_computation_model(str)\nFalse\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.BaseComputationModel","title":"batcharray.computation.BaseComputationModel","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Base class for computation models and defines interface methods.</p> <p>This class is public and should be used for other custom derived computation models.</p>"},{"location":"refs/computation/#batcharray.computation.BaseComputationModel.argmax","title":"batcharray.computation.BaseComputationModel.argmax  <code>abstractmethod</code>","text":"<pre><code>argmax(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the array of indices of the maximum values along the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the argmax are computed. The default (<code>None</code>) is to compute the argmax along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>The array of indices of the maximum values along the given axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import ArrayComputationModel\n&gt;&gt;&gt; comp_model = ArrayComputationModel()\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = comp_model.argmax(array, axis=0)\n&gt;&gt;&gt; out\narray([4, 4])\n&gt;&gt;&gt; out = comp_model.argmax(array, axis=1)\n&gt;&gt;&gt; out\narray([1, 1, 1, 1, 1])\n&gt;&gt;&gt; out = comp_model.argmax(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[4, 4]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.BaseComputationModel.argmin","title":"batcharray.computation.BaseComputationModel.argmin  <code>abstractmethod</code>","text":"<pre><code>argmin(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the array of indices of the minimum values along the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the argmin are computed. The default (<code>None</code>) is to compute the argmin along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>The array of indices of the minimum values along the given axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import ArrayComputationModel\n&gt;&gt;&gt; comp_model = ArrayComputationModel()\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = comp_model.argmin(array, axis=0)\n&gt;&gt;&gt; out\narray([0, 0])\n&gt;&gt;&gt; out = comp_model.argmin(array, axis=1)\n&gt;&gt;&gt; out\narray([0, 0, 0, 0, 0])\n&gt;&gt;&gt; out = comp_model.argmin(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[0, 0]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.BaseComputationModel.argsort","title":"batcharray.computation.BaseComputationModel.argsort  <code>abstractmethod</code>","text":"<pre><code>argsort(\n    arr: T,\n    axis: int | None = None,\n    *,\n    kind: SortKind | None = None\n) -&gt; T\n</code></pre> <p>Return the indices that sort an array along the given axis in ascending order by value.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the minimum values are computed. The default (<code>None</code>) is to compute the minimum along a flattened version of the array.</p> <code>None</code> <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>The indices that sort the array along the given axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import ArrayComputationModel\n&gt;&gt;&gt; comp_model = ArrayComputationModel()\n&gt;&gt;&gt; array = np.array([[3, 5, 0, 2, 4], [4, 7, 8, 9, 5], [7, 5, 8, 9, 0]])\n&gt;&gt;&gt; out = comp_model.argsort(array, axis=0)\n&gt;&gt;&gt; out\narray([[0, 0, 0, 0, 2],\n       [1, 2, 1, 1, 0],\n       [2, 1, 2, 2, 1]])\n&gt;&gt;&gt; out = comp_model.argsort(array, axis=1)\n&gt;&gt;&gt; out\narray([[2, 3, 0, 4, 1],\n       [0, 4, 1, 2, 3],\n       [4, 1, 0, 2, 3]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.BaseComputationModel.concatenate","title":"batcharray.computation.BaseComputationModel.concatenate  <code>abstractmethod</code>","text":"<pre><code>concatenate(\n    arrays: Sequence[T],\n    axis: int | None = None,\n    *,\n    dtype: DTypeLike = None\n) -&gt; T\n</code></pre> <p>Concatenate a sequence of arrays along an existing axis.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>Sequence[T]</code> <p>The arrays to concatenate.</p> required <code>axis</code> <code>int | None</code> <p>The axis along which the arrays will be joined. If <code>axis</code> is None, arrays are flattened before use.</p> <code>None</code> <code>dtype</code> <code>DTypeLike</code> <p>If provided, the destination array will have this data type.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>The concatenated array.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import ArrayComputationModel\n&gt;&gt;&gt; comp_model = ArrayComputationModel()\n&gt;&gt;&gt; arrays = [\n...     np.array([[0, 1, 2], [4, 5, 6]]),\n...     np.array([[10, 11, 12], [13, 14, 15]]),\n... ]\n&gt;&gt;&gt; out = comp_model.concatenate(arrays, axis=0)\n&gt;&gt;&gt; out\narray([[ 0,  1,  2],\n       [ 4,  5,  6],\n       [10, 11, 12],\n       [13, 14, 15]])\n&gt;&gt;&gt; out = comp_model.concatenate(arrays, axis=1)\n&gt;&gt;&gt; out\narray([[ 0,  1,  2, 10, 11, 12],\n       [ 4,  5,  6, 13, 14, 15]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.BaseComputationModel.max","title":"batcharray.computation.BaseComputationModel.max  <code>abstractmethod</code>","text":"<pre><code>max(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the maximum along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the maximum values are computed. The default (<code>None</code>) is to compute the maximum along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>The maximum of the input array along the given axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import ArrayComputationModel\n&gt;&gt;&gt; comp_model = ArrayComputationModel()\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = comp_model.max(array, axis=0)\n&gt;&gt;&gt; out\narray([8, 9])\n&gt;&gt;&gt; out = comp_model.max(array, axis=1)\n&gt;&gt;&gt; out\narray([1, 3, 5, 7, 9])\n&gt;&gt;&gt; out = comp_model.max(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[8, 9]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.BaseComputationModel.mean","title":"batcharray.computation.BaseComputationModel.mean  <code>abstractmethod</code>","text":"<pre><code>mean(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the mean along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the means are computed. The default (<code>None</code>) is to compute the mean along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>A new array holding the result. If the input contains integers or floats smaller than <code>np.float64</code>, then the output data-type is <code>np.float64</code>. Otherwise, the data-type of the output is the same as that of the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import ArrayComputationModel\n&gt;&gt;&gt; comp_model = ArrayComputationModel()\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = comp_model.mean(array, axis=0)\n&gt;&gt;&gt; out\narray([4., 5.])\n&gt;&gt;&gt; out = comp_model.mean(array, axis=1)\n&gt;&gt;&gt; out\narray([0.5, 2.5, 4.5, 6.5, 8.5])\n&gt;&gt;&gt; out = comp_model.mean(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[4., 5.]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.BaseComputationModel.median","title":"batcharray.computation.BaseComputationModel.median  <code>abstractmethod</code>","text":"<pre><code>median(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the median along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the medians are computed. The default (<code>None</code>) is to compute the median along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>A new array holding the result. If the input contains integers or floats smaller than <code>np.float64</code>, then the output data-type is <code>np.float64</code>. Otherwise, the data-type of the output is the same as that of the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import ArrayComputationModel\n&gt;&gt;&gt; comp_model = ArrayComputationModel()\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = comp_model.median(array, axis=0)\n&gt;&gt;&gt; out\narray([4., 5.])\n&gt;&gt;&gt; out = comp_model.median(array, axis=1)\n&gt;&gt;&gt; out\narray([0.5, 2.5, 4.5, 6.5, 8.5])\n&gt;&gt;&gt; out = comp_model.median(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[4., 5.]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.BaseComputationModel.min","title":"batcharray.computation.BaseComputationModel.min  <code>abstractmethod</code>","text":"<pre><code>min(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the minimum along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the minimum values are computed. The default (<code>None</code>) is to compute the minimum along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>The minimum of the input array along the given axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import ArrayComputationModel\n&gt;&gt;&gt; comp_model = ArrayComputationModel()\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = comp_model.min(array, axis=0)\n&gt;&gt;&gt; out\narray([0, 1])\n&gt;&gt;&gt; out = comp_model.min(array, axis=1)\n&gt;&gt;&gt; out\narray([0, 2, 4, 6, 8])\n&gt;&gt;&gt; out = comp_model.min(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[0, 1]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.BaseComputationModel.sort","title":"batcharray.computation.BaseComputationModel.sort  <code>abstractmethod</code>","text":"<pre><code>sort(\n    arr: T,\n    axis: int | None = None,\n    *,\n    kind: SortKind | None = None\n) -&gt; T\n</code></pre> <p>Sort the elements of the input array along the batch axis in ascending order by value.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the minimum values are computed. The default (<code>None</code>) is to compute the minimum along a flattened version of the array.</p> <code>None</code> <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>The sorted array along the given axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import ArrayComputationModel\n&gt;&gt;&gt; comp_model = ArrayComputationModel()\n&gt;&gt;&gt; array = np.array([[3, 5, 0, 2, 4], [4, 7, 8, 8, 5], [8, 5, 8, 8, 0]])\n&gt;&gt;&gt; out = comp_model.sort(array, axis=0)\n&gt;&gt;&gt; out\narray([[3, 5, 0, 2, 0],\n       [4, 5, 8, 8, 4],\n       [8, 7, 8, 8, 5]])\n&gt;&gt;&gt; out = comp_model.sort(array, axis=1)\n&gt;&gt;&gt; out\narray([[0, 2, 3, 4, 5],\n       [4, 5, 7, 8, 8],\n       [0, 5, 8, 8, 8]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.MaskedArrayComputationModel","title":"batcharray.computation.MaskedArrayComputationModel","text":"<p>               Bases: <code>BaseComputationModel[MaskedArray]</code></p> <p>Implement a computation model for <code>numpy.ma.MaskedArray</code>s.</p>"},{"location":"refs/computation/#batcharray.computation.argmax","title":"batcharray.computation.argmax","text":"<pre><code>argmax(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the array of indices of the maximum values along the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the argmax are computed. The default (<code>None</code>) is to compute the argmax along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>The array of indices of the maximum values along the given axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import argmax\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = argmax(array, axis=0)\n&gt;&gt;&gt; out\narray([4, 4])\n&gt;&gt;&gt; out = argmax(array, axis=1)\n&gt;&gt;&gt; out\narray([1, 1, 1, 1, 1])\n&gt;&gt;&gt; out = argmax(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[4, 4]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.argmin","title":"batcharray.computation.argmin","text":"<pre><code>argmin(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the array of indices of the minimum values along the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the argmin are computed. The default (<code>None</code>) is to compute the argmin along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>The array of indices of the minimum values along the given axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import argmin\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = argmin(array, axis=0)\n&gt;&gt;&gt; out\narray([0, 0])\n&gt;&gt;&gt; out = argmin(array, axis=1)\n&gt;&gt;&gt; out\narray([0, 0, 0, 0, 0])\n&gt;&gt;&gt; out = argmin(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[0, 0]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.argsort","title":"batcharray.computation.argsort","text":"<pre><code>argsort(\n    arr: T,\n    axis: int | None = None,\n    *,\n    kind: SortKind | None = None\n) -&gt; T\n</code></pre> <p>Return the indices that sort an array along the given axis in ascending order by value.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the minimum values are computed. The default (<code>None</code>) is to compute the minimum along a flattened version of the array.</p> <code>None</code> <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>The indices that sort the array along the given axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import ArrayComputationModel\n&gt;&gt;&gt; comp_model = ArrayComputationModel()\n&gt;&gt;&gt; array = np.array([[3, 5, 0, 2, 4], [4, 7, 8, 9, 5], [7, 5, 8, 9, 0]])\n&gt;&gt;&gt; out = comp_model.argsort(array, axis=0)\n&gt;&gt;&gt; out\narray([[0, 0, 0, 0, 2],\n       [1, 2, 1, 1, 0],\n       [2, 1, 2, 2, 1]])\n&gt;&gt;&gt; out = comp_model.argsort(array, axis=1)\n&gt;&gt;&gt; out\narray([[2, 3, 0, 4, 1],\n       [0, 4, 1, 2, 3],\n       [4, 1, 0, 2, 3]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.concatenate","title":"batcharray.computation.concatenate","text":"<pre><code>concatenate(\n    arrays: Sequence[T],\n    axis: int | None = None,\n    *,\n    dtype: DTypeLike = None\n) -&gt; T\n</code></pre> <p>Concatenate a sequence of arrays along an existing axis.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>Sequence[T]</code> <p>The arrays to concatenate.</p> required <code>axis</code> <code>int | None</code> <p>The axis along which the arrays will be joined. If <code>axis</code> is None, arrays are flattened before use.</p> <code>None</code> <code>dtype</code> <code>DTypeLike</code> <p>If provided, the destination array will have this data type.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>The concatenated array.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import concatenate\n&gt;&gt;&gt; arrays = [\n...     np.array([[0, 1, 2], [4, 5, 6]]),\n...     np.array([[10, 11, 12], [13, 14, 15]]),\n... ]\n&gt;&gt;&gt; out = concatenate(arrays, axis=0)\n&gt;&gt;&gt; out\narray([[ 0,  1,  2],\n       [ 4,  5,  6],\n       [10, 11, 12],\n       [13, 14, 15]])\n&gt;&gt;&gt; out = concatenate(arrays, axis=1)\n&gt;&gt;&gt; out\narray([[ 0,  1,  2, 10, 11, 12],\n       [ 4,  5,  6, 13, 14, 15]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.max","title":"batcharray.computation.max","text":"<pre><code>max(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the maximum along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the maximum values are computed. The default (<code>None</code>) is to compute the maximum along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>The maximum of the input array along the given axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import max\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = max(array, axis=0)\n&gt;&gt;&gt; out\narray([8, 9])\n&gt;&gt;&gt; out = max(array, axis=1)\n&gt;&gt;&gt; out\narray([1, 3, 5, 7, 9])\n&gt;&gt;&gt; out = max(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[8, 9]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.mean","title":"batcharray.computation.mean","text":"<pre><code>mean(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the mean along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the means are computed. The default (<code>None</code>) is to compute the mean along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>A new array holding the result. If the input contains integers or floats smaller than <code>np.float64</code>, then the output data-type is <code>np.float64</code>. Otherwise, the data-type of the output is the same as that of the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import mean\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = mean(array, axis=0)\n&gt;&gt;&gt; out\narray([4., 5.])\n&gt;&gt;&gt; out = mean(array, axis=1)\n&gt;&gt;&gt; out\narray([0.5, 2.5, 4.5, 6.5, 8.5])\n&gt;&gt;&gt; out = mean(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[4., 5.]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.median","title":"batcharray.computation.median","text":"<pre><code>median(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the median along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the medians are computed. The default (<code>None</code>) is to compute the median along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>A new array holding the result. If the input contains integers or floats smaller than <code>np.float64</code>, then the output data-type is <code>np.float64</code>. Otherwise, the data-type of the output is the same as that of the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import median\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = median(array, axis=0)\n&gt;&gt;&gt; out\narray([4., 5.])\n&gt;&gt;&gt; out = median(array, axis=1)\n&gt;&gt;&gt; out\narray([0.5, 2.5, 4.5, 6.5, 8.5])\n&gt;&gt;&gt; out = median(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[4., 5.]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.min","title":"batcharray.computation.min","text":"<pre><code>min(\n    arr: T,\n    axis: int | None = None,\n    *,\n    keepdims: bool = False\n) -&gt; T\n</code></pre> <p>Return the minimum along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the minimum values are computed. The default (<code>None</code>) is to compute the minimum along a flattened version of the array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>The minimum of the input array along the given axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import min\n&gt;&gt;&gt; array = np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\n&gt;&gt;&gt; out = min(array, axis=0)\n&gt;&gt;&gt; out\narray([0, 1])\n&gt;&gt;&gt; out = min(array, axis=1)\n&gt;&gt;&gt; out\narray([0, 2, 4, 6, 8])\n&gt;&gt;&gt; out = min(array, axis=0, keepdims=True)\n&gt;&gt;&gt; out\narray([[0, 1]])\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.register_computation_models","title":"batcharray.computation.register_computation_models","text":"<pre><code>register_computation_models() -&gt; None\n</code></pre> <p>Register computation models to <code>AutoComputationModel</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from batcharray.computation import AutoComputationModel, register_computation_models\n&gt;&gt;&gt; register_computation_models()\n&gt;&gt;&gt; comp_model = AutoComputationModel()\n&gt;&gt;&gt; comp_model\nAutoComputationModel(\n  ...\n)\n</code></pre>"},{"location":"refs/computation/#batcharray.computation.sort","title":"batcharray.computation.sort","text":"<pre><code>sort(\n    arr: T,\n    axis: int | None = None,\n    *,\n    kind: SortKind | None = None\n) -&gt; T\n</code></pre> <p>Sort the elements of the input array along the batch axis in ascending order by value.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>T</code> <p>The input array.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which the minimum values are computed. The default (<code>None</code>) is to compute the minimum along a flattened version of the array.</p> <code>None</code> <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>The sorted array along the given axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.computation import sort\n&gt;&gt;&gt; array = np.array([[3, 5, 0, 2, 4], [4, 7, 8, 8, 5], [8, 5, 8, 8, 0]])\n&gt;&gt;&gt; out = sort(array, axis=0)\n&gt;&gt;&gt; out\narray([[3, 5, 0, 2, 0],\n       [4, 5, 8, 8, 4],\n       [8, 7, 8, 8, 5]])\n&gt;&gt;&gt; out = sort(array, axis=1)\n&gt;&gt;&gt; out\narray([[0, 2, 3, 4, 5],\n       [4, 5, 7, 8, 8],\n       [0, 5, 8, 8, 8]])\n</code></pre>"},{"location":"refs/nested/","title":"nested","text":""},{"location":"refs/nested/#batcharray.nested","title":"batcharray.nested","text":"<p>Contain functions to manipulate nested data.</p>"},{"location":"refs/nested/#batcharray.nested.abs","title":"batcharray.nested.abs","text":"<pre><code>abs(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the absolute value of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The absolute value of the elements. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import abs\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[-4, -3], [-2, -1], [0, 1], [2, 3], [4, 5]]),\n...     \"b\": np.array([2, 1, 0, -1, -2]),\n... }\n&gt;&gt;&gt; out = abs(data)\n&gt;&gt;&gt; out\n{'a': array([[4, 3], [2, 1], [0, 1], [2, 3], [4, 5]]), 'b': array([2, 1, 0, 1, 2])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.amax_along_batch","title":"batcharray.nested.amax_along_batch","text":"<pre><code>amax_along_batch(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the maximum of all elements along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The maximum of all elements along the batch dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import amax_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = amax_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([8, 9]), 'b': np.int64(4)}\n&gt;&gt;&gt; out = amax_along_batch(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[8, 9]]), 'b': array([4])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.amax_along_seq","title":"batcharray.nested.amax_along_seq","text":"<pre><code>amax_along_seq(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the maximum of all elements along the sequence dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The maximum of all elements along the sequence dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import amax_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = amax_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([4, 9]), 'b': array([4])}\n&gt;&gt;&gt; out = amax_along_seq(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[4], [9]]), 'b': array([[4]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.amin_along_batch","title":"batcharray.nested.amin_along_batch","text":"<pre><code>amin_along_batch(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the minimum of all elements along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The minimum of all elements along the batch dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import amin_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = amin_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([0, 1]), 'b': np.int64(0)}\n&gt;&gt;&gt; out = amin_along_batch(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[0, 1]]), 'b': array([0])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.amin_along_seq","title":"batcharray.nested.amin_along_seq","text":"<pre><code>amin_along_seq(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the minimum of all elements along the sequence dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The minimum of all elements along the sequence dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import amin_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = amin_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([0, 5]), 'b': array([0])}\n&gt;&gt;&gt; out = amin_along_seq(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[0], [5]]), 'b': array([[0]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.arccos","title":"batcharray.nested.arccos","text":"<pre><code>arccos(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the inverse cosine of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The inverse cosine of the elements. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import arccos\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = arccos(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.arccosh","title":"batcharray.nested.arccosh","text":"<pre><code>arccosh(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the inverse hyperbolic cosine of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The inverse hyperbolic cosine of the elements. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import arccosh\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = arccosh(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.arcsin","title":"batcharray.nested.arcsin","text":"<pre><code>arcsin(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the arcsine of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The arcsine of the elements. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import arcsin\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = arcsin(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.arcsinh","title":"batcharray.nested.arcsinh","text":"<pre><code>arcsinh(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the inverse hyperbolic sine of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The inverse hyperbolic sine of the elements. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import arcsinh\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = arcsinh(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.arctan","title":"batcharray.nested.arctan","text":"<pre><code>arctan(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the arctangent of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The arctangent of the elements. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import arctan\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = arctan(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.arctanh","title":"batcharray.nested.arctanh","text":"<pre><code>arctanh(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the inverse hyperbolic tangent of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The inverse hyperbolic tangent of the elements. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import arctanh\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = arctanh(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.argmax_along_batch","title":"batcharray.nested.argmax_along_batch","text":"<pre><code>argmax_along_batch(\n    data: Any, keepdims: bool = False\n) -&gt; Any\n</code></pre> <p>Return the indices of the maximum value of all elements along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The indices of the maximum value of all elements along the batch dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import argmax_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = argmax_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([4, 4]), 'b': np.int64(0)}\n&gt;&gt;&gt; out = argmax_along_batch(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[4, 4]]), 'b': array([0])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.argmax_along_seq","title":"batcharray.nested.argmax_along_seq","text":"<pre><code>argmax_along_seq(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the indices of the maximum value of all elements along the sequence dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The indices of the maximum value of all elements along the sequence dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import argmax_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = argmax_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([4, 4]), 'b': array([0])}\n&gt;&gt;&gt; out = argmax_along_seq(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[4], [4]]), 'b': array([[0]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.argmin_along_batch","title":"batcharray.nested.argmin_along_batch","text":"<pre><code>argmin_along_batch(\n    data: Any, keepdims: bool = False\n) -&gt; Any\n</code></pre> <p>Return the indices of the minimum value of all elements along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The indices of the minimum value of all elements along the batch dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import argmin_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = argmin_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([0, 0]), 'b': np.int64(4)}\n&gt;&gt;&gt; out = argmin_along_batch(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[0, 0]]), 'b': array([4])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.argmin_along_seq","title":"batcharray.nested.argmin_along_seq","text":"<pre><code>argmin_along_seq(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the indices of the minimum value of all elements along the sequence dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The indices of the minimum value of all elements along the sequence dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import argmin_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = argmin_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([0, 0]), 'b': array([4])}\n&gt;&gt;&gt; out = argmin_along_seq(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[0], [0]]), 'b': array([[4]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.argsort_along_batch","title":"batcharray.nested.argsort_along_batch","text":"<pre><code>argsort_along_batch(\n    data: Any, kind: SortKind | None = None\n) -&gt; Any\n</code></pre> <p>Return the indices that sort each array along the batch dimension in ascending order by value.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The indices that sort each array along the batch dimension</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import argsort_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[2, 6], [0, 3], [4, 9], [8, 1], [5, 7]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = argsort_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([[1, 3], [0, 1], [2, 0], [4, 4], [3, 2]]), 'b': array([4, 3, 2, 1, 0])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.argsort_along_seq","title":"batcharray.nested.argsort_along_seq","text":"<pre><code>argsort_along_seq(\n    data: Any, kind: SortKind | None = None\n) -&gt; Any\n</code></pre> <p>Return the indices that sort each array along the sequence dimension in ascending order by value.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The indices that sort each array along the sequence dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import argsort_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[7, 3, 0, 8, 5], [1, 9, 6, 4, 2]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = argsort_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([[2, 1, 4, 0, 3], [0, 4, 3, 2, 1]]), 'b': array([[4, 3, 2, 1, 0]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.chunk_along_batch","title":"batcharray.nested.chunk_along_batch","text":"<pre><code>chunk_along_batch(\n    data: dict[Hashable, ndarray], chunks: int\n) -&gt; list[dict[Hashable, ndarray]]\n</code></pre> <p>Split all the arrays into chunks along the batch axis.</p> <p>Each chunk is a view of the input array.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[Hashable, ndarray]</code> <p>The input data. Each item must be an array.</p> required <code>chunks</code> <code>int</code> <p>Number of chunks to return.</p> required <p>Returns:</p> Type Description <code>list[dict[Hashable, ndarray]]</code> <p>The data chuncks.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import chunk_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; outputs = chunk_along_batch(data, chunks=3)\n&gt;&gt;&gt; outputs\n[{'a': array([[0, 1], [2, 3]]), 'b': array([4, 3])},\n {'a': array([[4, 5], [6, 7]]), 'b': array([2, 1])},\n {'a': array([[8, 9]]), 'b': array([0])}]\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.chunk_along_seq","title":"batcharray.nested.chunk_along_seq","text":"<pre><code>chunk_along_seq(\n    data: dict[Hashable, ndarray], chunks: int\n) -&gt; list[dict[Hashable, ndarray]]\n</code></pre> <p>Split all the arrays into chunks along the sequence axis.</p> <p>Each chunk is a view of the input array.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[Hashable, ndarray]</code> <p>The input data. Each item must be an array.</p> required <code>chunks</code> <code>int</code> <p>Number of chunks to return.</p> required <p>Returns:</p> Type Description <code>list[dict[Hashable, ndarray]]</code> <p>The data chuncks.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import chunk_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; outputs = chunk_along_seq(data, chunks=3)\n&gt;&gt;&gt; outputs\n[{'a': array([[0, 1], [5, 6]]), 'b': array([[4, 3]])},\n {'a': array([[2, 3], [7, 8]]), 'b': array([[2, 1]])},\n {'a': array([[4], [9]]), 'b': array([[0]])}]\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.clip","title":"batcharray.nested.clip","text":"<pre><code>clip(\n    data: Any,\n    a_min: float | None = None,\n    a_max: float | None = None,\n) -&gt; Any\n</code></pre> <p>Clamp all elements in input into the range <code>[min, max]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <code>a_min</code> <code>float | None</code> <p>The lower-bound of the range to be clamped to.</p> <code>None</code> <code>a_max</code> <code>float | None</code> <p>The upper-bound of the range to be clamped to.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The clamp value of the elements. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import clip\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]),\n...     \"b\": np.array([5, 4, 3, 2, 1]),\n... }\n&gt;&gt;&gt; out = clip(data, a_min=1, a_max=5)\n&gt;&gt;&gt; out\n{'a': array([[1, 2], [3, 4], [5, 5], [5, 5], [5, 5]]), 'b': array([5, 4, 3, 2, 1])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.concatenate_along_batch","title":"batcharray.nested.concatenate_along_batch","text":"<pre><code>concatenate_along_batch(\n    data: Sequence[dict[Hashable, ndarray]],\n) -&gt; dict[Hashable, ndarray]\n</code></pre> <p>Concatenate the given arrays in the batch axis.</p> <p>All arrays must either have the same data type and shape (except in the concatenating axis) or be empty.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict[Hashable, ndarray]]</code> <p>The input data to concatenate. The dictionaries must have the same keys.</p> required <p>Returns:</p> Type Description <code>dict[Hashable, ndarray]</code> <p>The concatenated arrays along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import concatenate_along_batch\n&gt;&gt;&gt; data = [\n...     {\n...         \"a\": np.array([[0, 1, 2], [4, 5, 6]]),\n...         \"b\": np.array([[10, 11, 12], [13, 14, 15]]),\n...     },\n...     {\"a\": np.array([[7, 8, 9]]), \"b\": np.array([[17, 18, 19]])},\n... ]\n&gt;&gt;&gt; out = concatenate_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([[0, 1, 2], [4, 5, 6], [7, 8, 9]]),\n 'b': array([[10, 11, 12], [13, 14, 15], [17, 18, 19]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.concatenate_along_seq","title":"batcharray.nested.concatenate_along_seq","text":"<pre><code>concatenate_along_seq(\n    data: Sequence[dict[Hashable, ndarray]],\n) -&gt; dict[Hashable, ndarray]\n</code></pre> <p>Concatenate the given arrays in the sequence axis.</p> <p>All arrays must either have the same data type and shape (except in the concatenating axis) or be empty.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[dict[Hashable, ndarray]]</code> <p>The input data to concatenate. The dictionaries must have the same keys.</p> required <p>Returns:</p> Type Description <code>dict[Hashable, ndarray]</code> <p>The concatenated arrays along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import concatenate_along_seq\n&gt;&gt;&gt; data = [\n...     {\n...         \"a\": np.array([[0, 1, 2], [4, 5, 6]]),\n...         \"b\": np.array([[10, 11, 12], [13, 14, 15]]),\n...     },\n...     {\"a\": np.array([[7], [8]]), \"b\": np.array([[17], [18]])},\n... ]\n&gt;&gt;&gt; out = concatenate_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([[0, 1, 2, 7], [4, 5, 6, 8]]),\n 'b': array([[10, 11, 12, 17], [13, 14, 15, 18]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.cos","title":"batcharray.nested.cos","text":"<pre><code>cos(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the cosine of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The cosine of the elements. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import cos\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = cos(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.cosh","title":"batcharray.nested.cosh","text":"<pre><code>cosh(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the hyperbolic cosine of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The inverse cosine of the elements. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import cosh\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = cosh(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.cumprod_along_batch","title":"batcharray.nested.cumprod_along_batch","text":"<pre><code>cumprod_along_batch(data: Any) -&gt; Any\n</code></pre> <p>Return the cumulative product of elements of input in the batch dimension.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The cumulative product of elements of input in the batch dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import cumprod_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = cumprod_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([[   1,    2], [   3,    8], [  15,   48], [ 105,  384], [ 945, 3840]]),\n 'b': array([ 4, 12, 24, 24,  0])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.cumprod_along_seq","title":"batcharray.nested.cumprod_along_seq","text":"<pre><code>cumprod_along_seq(data: Any) -&gt; Any\n</code></pre> <p>Return the cumulative product of elements of input in the sequence dimension.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The cumulative product of elements of input in the sequence dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import cumprod_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = cumprod_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([[    1,     2,     6,    24,   120], [    6,    42,   336,  3024, 30240]]),\n 'b': array([[ 4, 12, 24, 24,  0]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.cumsum_along_batch","title":"batcharray.nested.cumsum_along_batch","text":"<pre><code>cumsum_along_batch(data: Any) -&gt; Any\n</code></pre> <p>Return the cumulative sum of elements of input in the batch dimension.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The cumulative sum of elements of input in the batch dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import cumsum_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = cumsum_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([[ 0,  1], [ 2,  4], [ 6,  9], [12, 16], [20, 25]]),\n 'b': array([ 4,  7,  9, 10, 10])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.cumsum_along_seq","title":"batcharray.nested.cumsum_along_seq","text":"<pre><code>cumsum_along_seq(data: Any) -&gt; Any\n</code></pre> <p>Return the cumulative sum of elements of input in the sequence dimension.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The cumulative sum of elements of input in the sequence dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import cumsum_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = cumsum_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([[ 0,  1,  3,  6, 10], [ 5, 11, 18, 26, 35]]),\n 'b': array([[ 4,  7,  9, 10, 10]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.exp","title":"batcharray.nested.exp","text":"<pre><code>exp(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the exponential of the elements.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The exponential of the elements. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import exp\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]),\n...     \"b\": np.array([5, 4, 3, 2, 1]),\n... }\n&gt;&gt;&gt; out = exp(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.exp2","title":"batcharray.nested.exp2","text":"<pre><code>exp2(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the base two exponential of the elements.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The base two exponential of the elements. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import exp2\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]),\n...     \"b\": np.array([5, 4, 3, 2, 1]),\n... }\n&gt;&gt;&gt; out = exp2(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.expm1","title":"batcharray.nested.expm1","text":"<pre><code>expm1(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the exponential of the elements minus 1.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The exponential of the elements minus 1. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import expm1\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]),\n...     \"b\": np.array([5, 4, 3, 2, 1]),\n... }\n&gt;&gt;&gt; out = expm1(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.index_select_along_batch","title":"batcharray.nested.index_select_along_batch","text":"<pre><code>index_select_along_batch(\n    data: Any, indices: ndarray\n) -&gt; Any\n</code></pre> <p>Return the arrays which index the arrays along the batch axis using the entries in <code>indices</code>.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> Note <p>Equivalent to <code>take_along_batch</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>indices</code> <code>ndarray</code> <p>The 1-D array containing the indices to take.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The indexed arrays along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import index_select_along_batch\n&gt;&gt;&gt; arrays = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = index_select_along_batch(arrays, np.array([2, 4]))\n&gt;&gt;&gt; out\n{'a': array([[4, 5], [8, 9]]), 'b': array([2, 0])}\n&gt;&gt;&gt; out = index_select_along_batch(arrays, np.array([4, 3, 2, 1, 0]))\n&gt;&gt;&gt; out\n{'a': array([[8, 9], [6, 7], [4, 5], [2, 3], [0, 1]]), 'b': array([0, 1, 2, 3, 4])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.index_select_along_seq","title":"batcharray.nested.index_select_along_seq","text":"<pre><code>index_select_along_seq(data: Any, indices: ndarray) -&gt; Any\n</code></pre> <p>Return the arrays which index the arrays along the sequence axis using the entries in <code>indices</code>.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> Note <p>Equivalent to <code>take_along_seq</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>indices</code> <code>ndarray</code> <p>The 1-D array containing the indices to take.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The indexed arrays along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import index_select_along_seq\n&gt;&gt;&gt; arrays = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = index_select_along_seq(arrays, np.array([2, 4]))\n&gt;&gt;&gt; out\n{'a': array([[2, 4], [7, 9]]), 'b': array([[2, 0]])}\n&gt;&gt;&gt; out = index_select_along_seq(arrays, np.array([4, 3, 2, 1, 0]))\n&gt;&gt;&gt; out\n{'a': array([[4, 3, 2, 1, 0], [9, 8, 7, 6, 5]]), 'b': array([[0, 1, 2, 3, 4]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.log","title":"batcharray.nested.log","text":"<pre><code>log(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the natural logarithm of the elements.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The natural logarithm of the elements. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import log\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]),\n...     \"b\": np.array([5, 4, 3, 2, 1]),\n... }\n&gt;&gt;&gt; out = log(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.log10","title":"batcharray.nested.log10","text":"<pre><code>log10(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the logarithm to the base 10 of the elements.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The with the logarithm to the base 10 of the elements. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import log10\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]),\n...     \"b\": np.array([5, 4, 3, 2, 1]),\n... }\n&gt;&gt;&gt; out = log10(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.log1p","title":"batcharray.nested.log1p","text":"<pre><code>log1p(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the natural logarithm of <code>(1 + input)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The natural logarithm of <code>(1 + input)</code>. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import log1p\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]),\n...     \"b\": np.array([5, 4, 3, 2, 1]),\n... }\n&gt;&gt;&gt; out = log1p(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.log2","title":"batcharray.nested.log2","text":"<pre><code>log2(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the logarithm to the base 2 of the elements.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The logarithm to the base 2 of the elements. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import log2\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]),\n...     \"b\": np.array([5, 4, 3, 2, 1]),\n... }\n&gt;&gt;&gt; out = log2(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.masked_select_along_batch","title":"batcharray.nested.masked_select_along_batch","text":"<pre><code>masked_select_along_batch(data: Any, mask: ndarray) -&gt; Any\n</code></pre> <p>Return the arrays which index the arrays along the batch axis according to the boolean mask <code>mask</code>.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>mask</code> <code>ndarray</code> <p>The 1-D array containing the binary mask to index with.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The indexed arrays along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import masked_select_along_batch\n&gt;&gt;&gt; arrays = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = masked_select_along_batch(arrays, np.array([False, False, True, False, True]))\n&gt;&gt;&gt; out\n{'a': array([[4, 5], [8, 9]]), 'b': array([2, 0])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.masked_select_along_seq","title":"batcharray.nested.masked_select_along_seq","text":"<pre><code>masked_select_along_seq(data: Any, mask: ndarray) -&gt; Any\n</code></pre> <p>Return the arrays which index the arrays along the sequence axis according to the boolean mask <code>mask</code>.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>mask</code> <code>ndarray</code> <p>The 1-D array containing the binary mask to index with.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The indexed arrays along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import masked_select_along_seq\n&gt;&gt;&gt; arrays = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = masked_select_along_seq(arrays, np.array([False, False, True, False, True]))\n&gt;&gt;&gt; out\n{'a': array([[2, 4], [7, 9]]), 'b': array([[2, 0]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.max_along_batch","title":"batcharray.nested.max_along_batch","text":"<pre><code>max_along_batch(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the maximum of all elements along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The first array will be populated with the maximum values and  the second array, which must have dtype long, with their  indices in the batch dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import max_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = max_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([8, 9]), 'b': np.int64(4)}\n&gt;&gt;&gt; out = max_along_batch(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[8, 9]]), 'b': array([4])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.max_along_seq","title":"batcharray.nested.max_along_seq","text":"<pre><code>max_along_seq(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the maximum of all elements along the sequence dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The first array will be populated with the maximum values and the second array, which must have dtype long, with their indices in the sequence dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import max_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = max_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([4, 9]), 'b': array([4])}\n&gt;&gt;&gt; out = max_along_seq(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[4], [9]]), 'b': array([[4]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.mean_along_batch","title":"batcharray.nested.mean_along_batch","text":"<pre><code>mean_along_batch(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the mean of all elements along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The mean of all elements along the batch dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import mean_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0.0, 1.0], [2.0, 3.0], [4.0, 5.0], [6.0, 7.0], [8.0, 9.0]]),\n...     \"b\": np.array([4, 3, 2, 1, 0], dtype=np.float32),\n... }\n&gt;&gt;&gt; out = mean_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([4., 5.]), 'b': np.float32(2.0)}\n&gt;&gt;&gt; out = mean_along_batch(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[4., 5.]]), 'b': array([2.], dtype=float32)}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.mean_along_seq","title":"batcharray.nested.mean_along_seq","text":"<pre><code>mean_along_seq(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the mean of all elements along the sequence dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import mean_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0.0, 1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0, 9.0]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]], dtype=np.float32),\n... }\n&gt;&gt;&gt; out = mean_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([2., 7.]), 'b': array([2.], dtype=float32)}\n&gt;&gt;&gt; out = mean_along_seq(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[2.], [7.]]), 'b': array([[2.]], dtype=float32)}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.median_along_batch","title":"batcharray.nested.median_along_batch","text":"<pre><code>median_along_batch(\n    data: Any, keepdims: bool = False\n) -&gt; Any\n</code></pre> <p>Return the median of all elements along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The first array will be populated with the median values and the second array, which must have dtype long, with their indices in the batch dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import median_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = median_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([4., 5.]), 'b': np.float64(2.0)}\n&gt;&gt;&gt; out = median_along_batch(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[4., 5.]]), 'b': array([2.])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.median_along_seq","title":"batcharray.nested.median_along_seq","text":"<pre><code>median_along_seq(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the median of all elements along the sequence dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The first array will be populated with the median values and the second array, which must have dtype long, with their indices in the sequence dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import median_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = median_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([2., 7.]), 'b': array([2.])}\n&gt;&gt;&gt; out = median_along_seq(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[2.], [7.]]), 'b': array([[2.]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.min_along_batch","title":"batcharray.nested.min_along_batch","text":"<pre><code>min_along_batch(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the minimum of all elements along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The first array will be populated with the minimum values and the second array, which must have dtype long, with their indices in the batch dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import min_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = min_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([0, 1]), 'b': np.int64(0)}\n&gt;&gt;&gt; out = min_along_batch(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[0, 1]]), 'b': array([0])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.min_along_seq","title":"batcharray.nested.min_along_seq","text":"<pre><code>min_along_seq(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the minimum of all elements along the sequence dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The first array will be populated with the minimum values and the second array, which must have dtype long, with their indices in the sequence dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import min_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = min_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([0, 5]), 'b': array([0])}\n&gt;&gt;&gt; out = min_along_seq(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[0], [5]]), 'b': array([[0]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.permute_along_batch","title":"batcharray.nested.permute_along_batch","text":"<pre><code>permute_along_batch(data: Any, permutation: ndarray) -&gt; Any\n</code></pre> <p>Permute all the arrays along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>permutation</code> <code>ndarray</code> <p>The 1-D array containing the indices of the permutation. The shape should match the batch axis of the array.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The data with permuted arrays along the batch axis. The output data has the same structure as the input data.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the shape of the permutation does not match the batch axis of the array.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import permute_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = permute_along_batch(data, np.array([2, 1, 3, 0, 4]))\n&gt;&gt;&gt; out\n{'a': array([[4, 5], [2, 3], [6, 7], [0, 1], [8, 9]]), 'b': array([2, 3, 1, 4, 0])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.permute_along_seq","title":"batcharray.nested.permute_along_seq","text":"<pre><code>permute_along_seq(data: Any, permutation: ndarray) -&gt; Any\n</code></pre> <p>Permute all the arrays along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>permutation</code> <code>ndarray</code> <p>The 1-D array containing the indices of the permutation. The shape should match the sequence axis of the array.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The data with permuted arrays along the sequence axis. The output data has the same structure as the input data.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the shape of the permutation does not match the sequence axis of the array.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import permute_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = permute_along_seq(data, np.array([2, 1, 3, 0, 4]))\n&gt;&gt;&gt; out\n{'a': array([[2, 1, 3, 0, 4], [7, 6, 8, 5, 9]]), 'b': array([[2, 3, 1, 4, 0]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.prod_along_batch","title":"batcharray.nested.prod_along_batch","text":"<pre><code>prod_along_batch(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the product of all elements along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The product of all elements along the batch dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import prod_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([5, 4, 3, 2, 1]),\n... }\n&gt;&gt;&gt; out = prod_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([  0, 945]), 'b': np.int64(120)}\n&gt;&gt;&gt; out = prod_along_batch(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[  0, 945]]), 'b': array([120])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.prod_along_seq","title":"batcharray.nested.prod_along_seq","text":"<pre><code>prod_along_seq(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the product of all elements along the sequence dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The product of all elements along the sequence dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import prod_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[5, 4, 3, 2, 1]]),\n... }\n&gt;&gt;&gt; out = prod_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([    0, 15120]), 'b': array([120])}\n&gt;&gt;&gt; out = prod_along_seq(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[    0], [15120]]), 'b': array([[120]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.select_along_batch","title":"batcharray.nested.select_along_batch","text":"<pre><code>select_along_batch(data: Any, index: int) -&gt; Any\n</code></pre> <p>Slice the arrays along the batch axis at the given index.</p> <p>This function returns a view of the original array with the batch axis removed.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>index</code> <code>int</code> <p>The index to select with.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The sliced arrays along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import select_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = select_along_batch(data, index=2)\n&gt;&gt;&gt; out\n{'a': array([4, 5]), 'b': np.int64(2)}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.select_along_seq","title":"batcharray.nested.select_along_seq","text":"<pre><code>select_along_seq(data: Any, index: int) -&gt; Any\n</code></pre> <p>Slice the arrays along the sequence axis at the given index.</p> <p>This function returns a view of the original array with the sequence axis removed.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>index</code> <code>int</code> <p>The index to select with.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The sliced arrays along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import select_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = select_along_seq(data, index=2)\n&gt;&gt;&gt; out\n{'a': array([2, 7]), 'b': array([2])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.shuffle_along_batch","title":"batcharray.nested.shuffle_along_batch","text":"<pre><code>shuffle_along_batch(\n    data: Any, rng: Generator | None = None\n) -&gt; Any\n</code></pre> <p>Shuffle all the arrays along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>rng</code> <code>Generator | None</code> <p>An optional random number generator.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The data with shuffled arrays along the sequence axis. The output data has the same structure as the input data.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import shuffle_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = shuffle_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.shuffle_along_seq","title":"batcharray.nested.shuffle_along_seq","text":"<pre><code>shuffle_along_seq(\n    data: Any, rng: Generator | None = None\n) -&gt; Any\n</code></pre> <p>Shuffle all the arrays along the batch axis.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>rng</code> <code>Generator | None</code> <p>An optional random number generator.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The data with shuffled arrays along the sequence axis. The output data has the same structure as the input data.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import shuffle_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = shuffle_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([[...]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.sin","title":"batcharray.nested.sin","text":"<pre><code>sin(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the sine of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The sine of the elements. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import sin\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = sin(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.sinh","title":"batcharray.nested.sinh","text":"<pre><code>sinh(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the hyperbolic sine of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The hyperbolic sine of the elements. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import sinh\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = sinh(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.slice_along_batch","title":"batcharray.nested.slice_along_batch","text":"<pre><code>slice_along_batch(\n    data: Any,\n    start: int = 0,\n    stop: int | None = None,\n    step: int = 1,\n) -&gt; Any\n</code></pre> <p>Slice all the arrays along the batch axis.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>start</code> <code>int</code> <p>The index where the slicing of object starts.</p> <code>0</code> <code>stop</code> <code>int | None</code> <p>The index where the slicing of object stops. <code>None</code> means last.</p> <code>None</code> <code>step</code> <code>int</code> <p>The increment between each index for slicing.</p> <code>1</code> <p>Returns:</p> Type Description <code>Any</code> <p>The sliced array along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import slice_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = slice_along_batch(data, start=2)\n&gt;&gt;&gt; out\n{'a': array([[4, 5], [6, 7], [8, 9]]), 'b': array([2, 1, 0])}\n&gt;&gt;&gt; out = slice_along_batch(data, stop=3)\n&gt;&gt;&gt; out\n{'a': array([[0, 1], [2, 3], [4, 5]]), 'b': array([4, 3, 2])}\n&gt;&gt;&gt; out = slice_along_batch(data, step=2)\n&gt;&gt;&gt; out\n{'a': array([[0, 1], [4, 5], [8, 9]]), 'b': array([4, 2, 0])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.slice_along_seq","title":"batcharray.nested.slice_along_seq","text":"<pre><code>slice_along_seq(\n    data: Any,\n    start: int = 0,\n    stop: int | None = None,\n    step: int = 1,\n) -&gt; Any\n</code></pre> <p>Slice all the arrays along the batch axis.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>start</code> <code>int</code> <p>The index where the slicing of object starts.</p> <code>0</code> <code>stop</code> <code>int | None</code> <p>The index where the slicing of object stops. <code>None</code> means last.</p> <code>None</code> <code>step</code> <code>int</code> <p>The increment between each index for slicing.</p> <code>1</code> <p>Returns:</p> Type Description <code>Any</code> <p>The sliced array along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import slice_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = slice_along_seq(data, start=2)\n&gt;&gt;&gt; out\n{'a': array([[2, 3, 4], [7, 8, 9]]), 'b': array([[2, 1, 0]])}\n&gt;&gt;&gt; out = slice_along_seq(data, stop=3)\n&gt;&gt;&gt; out\n{'a': array([[0, 1, 2], [5, 6, 7]]), 'b': array([[4, 3, 2]])}\n&gt;&gt;&gt; out = slice_along_seq(data, step=2)\n&gt;&gt;&gt; out\n{'a': array([[0, 2, 4], [5, 7, 9]]), 'b': array([[4, 2, 0]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.sort_along_batch","title":"batcharray.nested.sort_along_batch","text":"<pre><code>sort_along_batch(\n    data: Any, kind: SortKind | None = None\n) -&gt; Any\n</code></pre> <p>Sort the elements of the input array along the batch dimension in ascending order by value.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>A similar object where each array is replaced by a sorted array along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import sort_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[2, 6], [0, 3], [4, 9], [8, 1], [5, 7]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = sort_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([[0, 1], [2, 3], [4, 6], [5, 7], [8, 9]]), 'b': array([0, 1, 2, 3, 4])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.sort_along_seq","title":"batcharray.nested.sort_along_seq","text":"<pre><code>sort_along_seq(\n    data: Any, kind: SortKind | None = None\n) -&gt; Any\n</code></pre> <p>Sort the elements of the input array along the sequence dimension in ascending order by value.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <code>kind</code> <code>SortKind | None</code> <p>Sorting algorithm. The default is <code>quicksort</code>. Note that both <code>stable</code> and <code>mergesort</code> use timsort under the covers and, in general, the actual implementation will vary with datatype. The <code>mergesort</code> option is retained for backwards compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>A similar object where each array is replaced by a sorted array along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import sort_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[7, 3, 0, 8, 5], [1, 9, 6, 4, 2]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = sort_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([[0, 3, 5, 7, 8], [1, 2, 4, 6, 9]]), 'b': array([[0, 1, 2, 3, 4]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.split_along_batch","title":"batcharray.nested.split_along_batch","text":"<pre><code>split_along_batch(\n    data: dict[Hashable, ndarray],\n    split_size_or_sections: int | Sequence[int],\n) -&gt; list[dict[Hashable, ndarray]]\n</code></pre> <p>Split all the arrays into chunks along the batch axis.</p> <p>Each chunk is a view of the original array.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[Hashable, ndarray]</code> <p>The input data. Each item must be an array.</p> required <code>split_size_or_sections</code> <code>int | Sequence[int]</code> <p>Size of a single chunk or list of sizes for each chunk</p> required <p>Returns:</p> Type Description <code>list[dict[Hashable, ndarray]]</code> <p>The data chuncks.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import split_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; outputs = split_along_batch(data, split_size_or_sections=2)\n&gt;&gt;&gt; outputs\n[{'a': array([[0, 1], [2, 3]]), 'b': array([4, 3])},\n {'a': array([[4, 5], [6, 7]]), 'b': array([2, 1])},\n {'a': array([[8, 9]]), 'b': array([0])}]\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.split_along_seq","title":"batcharray.nested.split_along_seq","text":"<pre><code>split_along_seq(\n    data: dict[Hashable, ndarray],\n    split_size_or_sections: int | Sequence[int],\n) -&gt; list[dict[Hashable, ndarray]]\n</code></pre> <p>Split all the arrays into chunks along the sequence axis.</p> <p>Each chunk is a view of the original array.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[Hashable, ndarray]</code> <p>The input data. Each item must be an array.</p> required <code>split_size_or_sections</code> <code>int | Sequence[int]</code> <p>Size of a single chunk or list of sizes for each chunk</p> required <p>Returns:</p> Type Description <code>list[dict[Hashable, ndarray]]</code> <p>The data chuncks.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import split_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; outputs = split_along_seq(data, split_size_or_sections=2)\n&gt;&gt;&gt; outputs\n[{'a': array([[0, 1], [5, 6]]), 'b': array([[4, 3]])},\n {'a': array([[2, 3], [7, 8]]), 'b': array([[2, 1]])},\n {'a': array([[4], [9]]), 'b': array([[0]])}]\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.sum_along_batch","title":"batcharray.nested.sum_along_batch","text":"<pre><code>sum_along_batch(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the sum of all elements along the batch dimension.</p> Note <p>This function assumes the batch dimension is the first     dimension of the arrays. All the arrays should have the     same batch size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The sum of all elements along the batch dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import sum_along_batch\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = sum_along_batch(data)\n&gt;&gt;&gt; out\n{'a': array([20, 25]), 'b': np.int64(10)}\n&gt;&gt;&gt; out = sum_along_batch(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[20, 25]]), 'b': array([10])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.sum_along_seq","title":"batcharray.nested.sum_along_seq","text":"<pre><code>sum_along_seq(data: Any, keepdims: bool = False) -&gt; Any\n</code></pre> <p>Return the sum of all elements along the sequence dimension.</p> Note <p>This function assumes the sequence dimension is the second     dimension of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a array.</p> required <code>keepdims</code> <code>bool</code> <p>Whether the output array has dim retained or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The sum of all elements along the sequence dimension.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import sum_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = sum_along_seq(data)\n&gt;&gt;&gt; out\n{'a': array([10, 35]), 'b': array([10])}\n&gt;&gt;&gt; out = sum_along_seq(data, keepdims=True)\n&gt;&gt;&gt; out\n{'a': array([[10], [35]]), 'b': array([[10]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.take_along_batch","title":"batcharray.nested.take_along_batch","text":"<pre><code>take_along_batch(data: Any, indices: ndarray) -&gt; Any\n</code></pre> <p>Return the arrays which index the arrays along the batch axis using the entries in <code>indices</code>.</p> Note <p>This function assumes the batch axis is the first     axis of the arrays. All the arrays should have the     same batch size.</p> Note <p>Equivalent to <code>index_select_along_batch</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>indices</code> <code>ndarray</code> <p>The 1-D array containing the indices to take.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The indexed arrays along the batch axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import take_along_batch\n&gt;&gt;&gt; arrays = {\n...     \"a\": np.array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]),\n...     \"b\": np.array([4, 3, 2, 1, 0]),\n... }\n&gt;&gt;&gt; out = take_along_batch(arrays, np.array([2, 4]))\n&gt;&gt;&gt; out\n{'a': array([[4, 5], [8, 9]]), 'b': array([2, 0])}\n&gt;&gt;&gt; out = take_along_batch(arrays, np.array([4, 3, 2, 1, 0]))\n&gt;&gt;&gt; out\n{'a': array([[8, 9], [6, 7], [4, 5], [2, 3], [0, 1]]), 'b': array([0, 1, 2, 3, 4])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.take_along_seq","title":"batcharray.nested.take_along_seq","text":"<pre><code>take_along_seq(data: Any, indices: ndarray) -&gt; Any\n</code></pre> <p>Return the arrays which index the arrays along the sequence axis using the entries in <code>indices</code>.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> Note <p>Equivalent to <code>index_select_along_seq</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>indices</code> <code>ndarray</code> <p>The 1-D array containing the indices to take.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The indexed arrays along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import take_along_seq\n&gt;&gt;&gt; arrays = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = take_along_seq(arrays, np.array([2, 4]))\n&gt;&gt;&gt; out\n{'a': array([[2, 4], [7, 9]]), 'b': array([[2, 0]])}\n&gt;&gt;&gt; out = take_along_seq(arrays, np.array([4, 3, 2, 1, 0]))\n&gt;&gt;&gt; out\n{'a': array([[4, 3, 2, 1, 0], [9, 8, 7, 6, 5]]), 'b': array([[0, 1, 2, 3, 4]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.tan","title":"batcharray.nested.tan","text":"<pre><code>tan(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the tangent of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The tangent of the elements. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import tan\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = tan(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.tanh","title":"batcharray.nested.tanh","text":"<pre><code>tanh(data: Any) -&gt; Any\n</code></pre> <p>Return new arrays with the hyperbolic tangent of each element.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array .</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The hyperbolic tangent of the elements. The output has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import tanh\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 3)), \"b\": np.arange(5)}\n&gt;&gt;&gt; out = tanh(data)\n&gt;&gt;&gt; out\n{'a': array([[...]]), 'b': array([...])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.tile_along_seq","title":"batcharray.nested.tile_along_seq","text":"<pre><code>tile_along_seq(data: Any, reps: int) -&gt; Any\n</code></pre> <p>Repeat all the arrays along the sequence axis.</p> Note <p>This function assumes the sequence axis is the second     axis of the arrays. All the arrays should have the     same sequence size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be an array.</p> required <code>reps</code> <code>int</code> <p>The number of repetitions data along the sequence axis.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The arrays repeated along the sequence axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import tile_along_seq\n&gt;&gt;&gt; data = {\n...     \"a\": np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]),\n...     \"b\": np.array([[4, 3, 2, 1, 0]]),\n... }\n&gt;&gt;&gt; out = tile_along_seq(data, 2)\n&gt;&gt;&gt; out\n{'a': array([[0, 1, 2, 3, 4, 0, 1, 2, 3, 4], [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]]),\n 'b': array([[4, 3, 2, 1, 0, 4, 3, 2, 1, 0]])}\n</code></pre>"},{"location":"refs/nested/#batcharray.nested.to_list","title":"batcharray.nested.to_list","text":"<pre><code>to_list(data: Any) -&gt; Any\n</code></pre> <p>Create a new nested data structure where the <code>numpy.ndarray</code>s are converted to lists.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data. Each item must be a <code>numpy.ndarray</code>.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>A nested data structure with `lists instead of <code>numpy.ndarray</code>s. The output data has the same structure as the input.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.nested import to_list\n&gt;&gt;&gt; data = {\"a\": np.ones((2, 5)), \"b\": np.array([0, 1, 2, 3, 4])}\n&gt;&gt;&gt; out = to_list(data)\n&gt;&gt;&gt; out\n{'a': [[1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0]], 'b': [0, 1, 2, 3, 4]}\n</code></pre>"},{"location":"refs/recursive/","title":"recursive","text":""},{"location":"refs/recursive/#batcharray.recursive","title":"batcharray.recursive","text":"<p>Contain features to easily work on nested objects.</p>"},{"location":"refs/recursive/#batcharray.recursive.ApplyState","title":"batcharray.recursive.ApplyState  <code>dataclass</code>","text":"<p>Store the current state.</p>"},{"location":"refs/recursive/#batcharray.recursive.AutoApplier","title":"batcharray.recursive.AutoApplier","text":"<p>               Bases: <code>BaseApplier[Any]</code></p> <p>Implement an applier that can automatically call other appliers based on the data type.</p>"},{"location":"refs/recursive/#batcharray.recursive.AutoApplier.add_applier","title":"batcharray.recursive.AutoApplier.add_applier  <code>classmethod</code>","text":"<pre><code>add_applier(\n    data_type: type,\n    applier: BaseApplier,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add an applier for a given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The data type for this test.</p> required <code>applier</code> <code>BaseApplier</code> <p>The applier object.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the data type already exists. This parameter should be set to <code>True</code> to overwrite the applier for a type.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a applier is already registered for the data type and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from batcharray.recursive import AutoApplier, SequenceApplier\n&gt;&gt;&gt; AutoApplier.add_applier(list, SequenceApplier(), exist_ok=True)\n</code></pre>"},{"location":"refs/recursive/#batcharray.recursive.AutoApplier.find_applier","title":"batcharray.recursive.AutoApplier.find_applier  <code>classmethod</code>","text":"<pre><code>find_applier(data_type: Any) -&gt; BaseApplier\n</code></pre> <p>Find the applier associated to an object.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>Any</code> <p>The data type to get.</p> required <p>Returns:</p> Type Description <code>BaseApplier</code> <p>The applier associated to the data type.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from batcharray.recursive import AutoApplier\n&gt;&gt;&gt; AutoApplier.find_applier(list)\nSequenceApplier()\n</code></pre>"},{"location":"refs/recursive/#batcharray.recursive.AutoApplier.has_applier","title":"batcharray.recursive.AutoApplier.has_applier  <code>classmethod</code>","text":"<pre><code>has_applier(data_type: type) -&gt; bool\n</code></pre> <p>Indicate if an applier is registered for the given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The data type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if an applier is registered, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from batcharray.recursive import AutoApplier\n&gt;&gt;&gt; AutoApplier.has_applier(list)\nTrue\n&gt;&gt;&gt; AutoApplier.has_applier(str)\nFalse\n</code></pre>"},{"location":"refs/recursive/#batcharray.recursive.BaseApplier","title":"batcharray.recursive.BaseApplier","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to implement a recursive applier.</p>"},{"location":"refs/recursive/#batcharray.recursive.BaseApplier.apply","title":"batcharray.recursive.BaseApplier.apply  <code>abstractmethod</code>","text":"<pre><code>apply(data: T, func: Callable, state: ApplyState) -&gt; T\n</code></pre> <p>Recursively apply a function on all the items in a nested data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The input data.</p> required <code>func</code> <code>Callable</code> <p>The function to apply on each item.</p> required <code>state</code> <code>ApplyState</code> <p>The current state.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The transformed data.</p>"},{"location":"refs/recursive/#batcharray.recursive.DefaultApplier","title":"batcharray.recursive.DefaultApplier","text":"<p>               Bases: <code>BaseApplier[Any]</code></p> <p>Define the default applier.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from batcharray.recursive import DefaultApplier, AutoApplier, ApplyState\n&gt;&gt;&gt; state = ApplyState(applier=AutoApplier())\n&gt;&gt;&gt; applier = DefaultApplier()\n&gt;&gt;&gt; applier\nDefaultApplier()\n&gt;&gt;&gt; out = applier.apply([1, \"abc\"], str, state)\n&gt;&gt;&gt; out\n\"[1, 'abc']\"\n</code></pre>"},{"location":"refs/recursive/#batcharray.recursive.MappingApplier","title":"batcharray.recursive.MappingApplier","text":"<p>               Bases: <code>BaseApplier[T]</code></p> <p>Define an applier for mappings/dictionaries.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from batcharray.recursive import MappingApplier, AutoApplier, ApplyState\n&gt;&gt;&gt; state = ApplyState(applier=AutoApplier())\n&gt;&gt;&gt; applier = MappingApplier()\n&gt;&gt;&gt; applier\nMappingApplier()\n&gt;&gt;&gt; out = applier.apply({\"a\": 1, \"b\": \"abc\"}, str, state)\n&gt;&gt;&gt; out\n{'a': '1', 'b': 'abc'}\n</code></pre>"},{"location":"refs/recursive/#batcharray.recursive.SequenceApplier","title":"batcharray.recursive.SequenceApplier","text":"<p>               Bases: <code>BaseApplier[T]</code></p> <p>Define a applier for sequences/lists/tuples.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from batcharray.recursive import SequenceApplier, AutoApplier, ApplyState\n&gt;&gt;&gt; state = ApplyState(applier=AutoApplier())\n&gt;&gt;&gt; applier = SequenceApplier()\n&gt;&gt;&gt; applier\nSequenceApplier()\n&gt;&gt;&gt; out = applier.apply([1, \"abc\"], str, state)\n&gt;&gt;&gt; out\n['1', 'abc']\n</code></pre>"},{"location":"refs/recursive/#batcharray.recursive.recursive_apply","title":"batcharray.recursive.recursive_apply","text":"<pre><code>recursive_apply(data: Any, func: Callable) -&gt; Any\n</code></pre> <p>Recursively apply a function on all the items in a nested data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data.</p> required <code>func</code> <code>Callable</code> <p>The function to apply on each item.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The transformed data.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from batcharray.recursive import recursive_apply\n&gt;&gt;&gt; out = recursive_apply({\"a\": 1, \"b\": \"abc\"}, str)\n&gt;&gt;&gt; out\n{'a': '1', 'b': 'abc'}\n</code></pre>"},{"location":"refs/utils/","title":"utils","text":""},{"location":"refs/utils/#batcharray.utils","title":"batcharray.utils","text":"<p>Contain utility functions.</p>"},{"location":"refs/utils/#batcharray.utils.bfs_array","title":"batcharray.utils.bfs_array","text":"<pre><code>bfs_array(data: Any) -&gt; Generator[ndarray]\n</code></pre> <p>Implement a Breadth-First Search (BFS) iterator over the <code>numpy.ndarray</code>s.</p> <p>This function assumes the underlying data has a tree-like structure.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Specifies the data to iterate on.</p> required <p>Yields:</p> Type Description <code>Generator[ndarray]</code> <p>The next <code>numpy.ndarray</code> in the data.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.utils import bfs_array\n&gt;&gt;&gt; list(bfs_array([\"abc\", np.ones((2, 3)), 42, np.array([0, 1, 2, 3, 4])]))\n[array([[1., 1., 1.], [1., 1., 1.]]), array([0, 1, 2, 3, 4])]\n</code></pre>"},{"location":"refs/utils/#batcharray.utils.dfs_array","title":"batcharray.utils.dfs_array","text":"<pre><code>dfs_array(data: Any) -&gt; Generator[ndarray]\n</code></pre> <p>Implement a Depth-First Search (DFS) iterator over the <code>np.ndarray</code>s.</p> <p>This function assumes the underlying data has a tree-like structure.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Specifies the data to iterate on.</p> required <p>Yields:</p> Type Description <code>Generator[ndarray]</code> <p>The next <code>np.ndarray</code> in the data.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from batcharray.utils.dfs import dfs_array\n&gt;&gt;&gt; list(dfs_array([\"abc\", np.ones((2, 3)), 42, np.array([0, 1, 2, 3, 4])]))\n[array([[1., 1., 1.], [1., 1., 1.]]), array([0, 1, 2, 3, 4])]\n</code></pre>"},{"location":"uguide/array/","title":"Tensor","text":""},{"location":"uguide/array/#batch","title":"Batch","text":"<p><code>batcharray</code> provides functions to manipulate arrays representing a batch of examples. The functions assume the arrays have the following shape: <code>batch_size, *</code> where <code>*</code> means any axes.</p>"},{"location":"uguide/array/#sequence","title":"Sequence","text":"<p><code>batcharray</code> provides functions to manipulate arrays representing a batch of sequences. The functions assume the arrays have the following shape: <code>batch_size, seq_len, *</code> where <code>*</code> means any axes.</p>"}]}